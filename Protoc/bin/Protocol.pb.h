// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class ActionRequest;
struct ActionRequestDefaultTypeInternal;
extern ActionRequestDefaultTypeInternal _ActionRequest_default_instance_;
class ActionResponse;
struct ActionResponseDefaultTypeInternal;
extern ActionResponseDefaultTypeInternal _ActionResponse_default_instance_;
class ChatRequest;
struct ChatRequestDefaultTypeInternal;
extern ChatRequestDefaultTypeInternal _ChatRequest_default_instance_;
class ChatResponse;
struct ChatResponseDefaultTypeInternal;
extern ChatResponseDefaultTypeInternal _ChatResponse_default_instance_;
class CreateRoomRequest;
struct CreateRoomRequestDefaultTypeInternal;
extern CreateRoomRequestDefaultTypeInternal _CreateRoomRequest_default_instance_;
class CreateRoomResponse;
struct CreateRoomResponseDefaultTypeInternal;
extern CreateRoomResponseDefaultTypeInternal _CreateRoomResponse_default_instance_;
class EnterGameRequest;
struct EnterGameRequestDefaultTypeInternal;
extern EnterGameRequestDefaultTypeInternal _EnterGameRequest_default_instance_;
class EnterGameResponse;
struct EnterGameResponseDefaultTypeInternal;
extern EnterGameResponseDefaultTypeInternal _EnterGameResponse_default_instance_;
class JoinRoomRequest;
struct JoinRoomRequestDefaultTypeInternal;
extern JoinRoomRequestDefaultTypeInternal _JoinRoomRequest_default_instance_;
class JoinRoomResponse;
struct JoinRoomResponseDefaultTypeInternal;
extern JoinRoomResponseDefaultTypeInternal _JoinRoomResponse_default_instance_;
class ListRoomsRequest;
struct ListRoomsRequestDefaultTypeInternal;
extern ListRoomsRequestDefaultTypeInternal _ListRoomsRequest_default_instance_;
class ListRoomsResponse;
struct ListRoomsResponseDefaultTypeInternal;
extern ListRoomsResponseDefaultTypeInternal _ListRoomsResponse_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PlayerMoveRequest;
struct PlayerMoveRequestDefaultTypeInternal;
extern PlayerMoveRequestDefaultTypeInternal _PlayerMoveRequest_default_instance_;
class PlayerMoveResponse;
struct PlayerMoveResponseDefaultTypeInternal;
extern PlayerMoveResponseDefaultTypeInternal _PlayerMoveResponse_default_instance_;
class RoomInfo;
struct RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class WorldStateUpdate;
struct WorldStateUpdateDefaultTypeInternal;
extern WorldStateUpdateDefaultTypeInternal _WorldStateUpdate_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::ActionRequest* Arena::CreateMaybeMessage<::Protocol::ActionRequest>(Arena*);
template<> ::Protocol::ActionResponse* Arena::CreateMaybeMessage<::Protocol::ActionResponse>(Arena*);
template<> ::Protocol::ChatRequest* Arena::CreateMaybeMessage<::Protocol::ChatRequest>(Arena*);
template<> ::Protocol::ChatResponse* Arena::CreateMaybeMessage<::Protocol::ChatResponse>(Arena*);
template<> ::Protocol::CreateRoomRequest* Arena::CreateMaybeMessage<::Protocol::CreateRoomRequest>(Arena*);
template<> ::Protocol::CreateRoomResponse* Arena::CreateMaybeMessage<::Protocol::CreateRoomResponse>(Arena*);
template<> ::Protocol::EnterGameRequest* Arena::CreateMaybeMessage<::Protocol::EnterGameRequest>(Arena*);
template<> ::Protocol::EnterGameResponse* Arena::CreateMaybeMessage<::Protocol::EnterGameResponse>(Arena*);
template<> ::Protocol::JoinRoomRequest* Arena::CreateMaybeMessage<::Protocol::JoinRoomRequest>(Arena*);
template<> ::Protocol::JoinRoomResponse* Arena::CreateMaybeMessage<::Protocol::JoinRoomResponse>(Arena*);
template<> ::Protocol::ListRoomsRequest* Arena::CreateMaybeMessage<::Protocol::ListRoomsRequest>(Arena*);
template<> ::Protocol::ListRoomsResponse* Arena::CreateMaybeMessage<::Protocol::ListRoomsResponse>(Arena*);
template<> ::Protocol::LoginRequest* Arena::CreateMaybeMessage<::Protocol::LoginRequest>(Arena*);
template<> ::Protocol::LoginResponse* Arena::CreateMaybeMessage<::Protocol::LoginResponse>(Arena*);
template<> ::Protocol::PlayerInfo* Arena::CreateMaybeMessage<::Protocol::PlayerInfo>(Arena*);
template<> ::Protocol::PlayerMoveRequest* Arena::CreateMaybeMessage<::Protocol::PlayerMoveRequest>(Arena*);
template<> ::Protocol::PlayerMoveResponse* Arena::CreateMaybeMessage<::Protocol::PlayerMoveResponse>(Arena*);
template<> ::Protocol::RoomInfo* Arena::CreateMaybeMessage<::Protocol::RoomInfo>(Arena*);
template<> ::Protocol::WorldStateUpdate* Arena::CreateMaybeMessage<::Protocol::WorldStateUpdate>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNicknameFieldNumber = 1,
  };
  // string userNickname = 1;
  void clear_usernickname();
  const std::string& usernickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_usernickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_usernickname();
  PROTOBUF_NODISCARD std::string* release_usernickname();
  void set_allocated_usernickname(std::string* usernickname);
  private:
  const std::string& _internal_usernickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_usernickname(const std::string& value);
  std::string* _internal_mutable_usernickname();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr usernickname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kUserNicknameFieldNumber = 4,
    kSuccessFieldNumber = 1,
    kPlayerIDFieldNumber = 3,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // string userNickname = 4;
  void clear_usernickname();
  const std::string& usernickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_usernickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_usernickname();
  PROTOBUF_NODISCARD std::string* release_usernickname();
  void set_allocated_usernickname(std::string* usernickname);
  private:
  const std::string& _internal_usernickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_usernickname(const std::string& value);
  std::string* _internal_mutable_usernickname();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // uint32 playerID = 3;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.LoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr usernickname_;
    bool success_;
    uint32_t playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CreateRoomRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CreateRoomRequest) */ {
 public:
  inline CreateRoomRequest() : CreateRoomRequest(nullptr) {}
  ~CreateRoomRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoomRequest(const CreateRoomRequest& from);
  CreateRoomRequest(CreateRoomRequest&& from) noexcept
    : CreateRoomRequest() {
    *this = ::std::move(from);
  }

  inline CreateRoomRequest& operator=(const CreateRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoomRequest& operator=(CreateRoomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoomRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRoomRequest*>(
               &_CreateRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateRoomRequest& a, CreateRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRoomRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRoomRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRoomRequest& from) {
    CreateRoomRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoomRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CreateRoomRequest";
  }
  protected:
  explicit CreateRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatorIdFieldNumber = 1,
  };
  // uint64 creatorId = 1;
  void clear_creatorid();
  uint64_t creatorid() const;
  void set_creatorid(uint64_t value);
  private:
  uint64_t _internal_creatorid() const;
  void _internal_set_creatorid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CreateRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t creatorid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CreateRoomResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CreateRoomResponse) */ {
 public:
  inline CreateRoomResponse() : CreateRoomResponse(nullptr) {}
  ~CreateRoomResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateRoomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoomResponse(const CreateRoomResponse& from);
  CreateRoomResponse(CreateRoomResponse&& from) noexcept
    : CreateRoomResponse() {
    *this = ::std::move(from);
  }

  inline CreateRoomResponse& operator=(const CreateRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoomResponse& operator=(CreateRoomResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoomResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRoomResponse*>(
               &_CreateRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateRoomResponse& a, CreateRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoomResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoomResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRoomResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRoomResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRoomResponse& from) {
    CreateRoomResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoomResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CreateRoomResponse";
  }
  protected:
  explicit CreateRoomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kRoomIdFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string error = 2;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // uint64 roomId = 3;
  void clear_roomid();
  uint64_t roomid() const;
  void set_roomid(uint64_t value);
  private:
  uint64_t _internal_roomid() const;
  void _internal_set_roomid(uint64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CreateRoomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    uint64_t roomid_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class ListRoomsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.ListRoomsRequest) */ {
 public:
  inline ListRoomsRequest() : ListRoomsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ListRoomsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRoomsRequest(const ListRoomsRequest& from);
  ListRoomsRequest(ListRoomsRequest&& from) noexcept
    : ListRoomsRequest() {
    *this = ::std::move(from);
  }

  inline ListRoomsRequest& operator=(const ListRoomsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRoomsRequest& operator=(ListRoomsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRoomsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRoomsRequest* internal_default_instance() {
    return reinterpret_cast<const ListRoomsRequest*>(
               &_ListRoomsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ListRoomsRequest& a, ListRoomsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRoomsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRoomsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRoomsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRoomsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListRoomsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListRoomsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ListRoomsRequest";
  }
  protected:
  explicit ListRoomsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.ListRoomsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class ListRoomsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ListRoomsResponse) */ {
 public:
  inline ListRoomsResponse() : ListRoomsResponse(nullptr) {}
  ~ListRoomsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListRoomsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRoomsResponse(const ListRoomsResponse& from);
  ListRoomsResponse(ListRoomsResponse&& from) noexcept
    : ListRoomsResponse() {
    *this = ::std::move(from);
  }

  inline ListRoomsResponse& operator=(const ListRoomsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRoomsResponse& operator=(ListRoomsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRoomsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRoomsResponse* internal_default_instance() {
    return reinterpret_cast<const ListRoomsResponse*>(
               &_ListRoomsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListRoomsResponse& a, ListRoomsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRoomsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRoomsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRoomsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRoomsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRoomsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListRoomsResponse& from) {
    ListRoomsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRoomsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ListRoomsResponse";
  }
  protected:
  explicit ListRoomsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsFieldNumber = 1,
  };
  // repeated .Protocol.RoomInfo rooms = 1;
  int rooms_size() const;
  private:
  int _internal_rooms_size() const;
  public:
  void clear_rooms();
  ::Protocol::RoomInfo* mutable_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >*
      mutable_rooms();
  private:
  const ::Protocol::RoomInfo& _internal_rooms(int index) const;
  ::Protocol::RoomInfo* _internal_add_rooms();
  public:
  const ::Protocol::RoomInfo& rooms(int index) const;
  ::Protocol::RoomInfo* add_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >&
      rooms() const;

  // @@protoc_insertion_point(class_scope:Protocol.ListRoomsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo > rooms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class JoinRoomRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.JoinRoomRequest) */ {
 public:
  inline JoinRoomRequest() : JoinRoomRequest(nullptr) {}
  ~JoinRoomRequest() override;
  explicit PROTOBUF_CONSTEXPR JoinRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinRoomRequest(const JoinRoomRequest& from);
  JoinRoomRequest(JoinRoomRequest&& from) noexcept
    : JoinRoomRequest() {
    *this = ::std::move(from);
  }

  inline JoinRoomRequest& operator=(const JoinRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRoomRequest& operator=(JoinRoomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRoomRequest* internal_default_instance() {
    return reinterpret_cast<const JoinRoomRequest*>(
               &_JoinRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(JoinRoomRequest& a, JoinRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRoomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinRoomRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinRoomRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinRoomRequest& from) {
    JoinRoomRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRoomRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.JoinRoomRequest";
  }
  protected:
  explicit JoinRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kRoomIdFieldNumber = 2,
  };
  // uint64 playerId = 1;
  void clear_playerid();
  uint64_t playerid() const;
  void set_playerid(uint64_t value);
  private:
  uint64_t _internal_playerid() const;
  void _internal_set_playerid(uint64_t value);
  public:

  // uint64 roomId = 2;
  void clear_roomid();
  uint64_t roomid() const;
  void set_roomid(uint64_t value);
  private:
  uint64_t _internal_roomid() const;
  void _internal_set_roomid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.JoinRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t playerid_;
    uint64_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class JoinRoomResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.JoinRoomResponse) */ {
 public:
  inline JoinRoomResponse() : JoinRoomResponse(nullptr) {}
  ~JoinRoomResponse() override;
  explicit PROTOBUF_CONSTEXPR JoinRoomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinRoomResponse(const JoinRoomResponse& from);
  JoinRoomResponse(JoinRoomResponse&& from) noexcept
    : JoinRoomResponse() {
    *this = ::std::move(from);
  }

  inline JoinRoomResponse& operator=(const JoinRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRoomResponse& operator=(JoinRoomResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRoomResponse* internal_default_instance() {
    return reinterpret_cast<const JoinRoomResponse*>(
               &_JoinRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(JoinRoomResponse& a, JoinRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRoomResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRoomResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinRoomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinRoomResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinRoomResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinRoomResponse& from) {
    JoinRoomResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRoomResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.JoinRoomResponse";
  }
  protected:
  explicit JoinRoomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kRoomFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string error = 2;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .Protocol.RoomInfo room = 3;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::Protocol::RoomInfo& room() const;
  PROTOBUF_NODISCARD ::Protocol::RoomInfo* release_room();
  ::Protocol::RoomInfo* mutable_room();
  void set_allocated_room(::Protocol::RoomInfo* room);
  private:
  const ::Protocol::RoomInfo& _internal_room() const;
  ::Protocol::RoomInfo* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::Protocol::RoomInfo* room);
  ::Protocol::RoomInfo* unsafe_arena_release_room();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.JoinRoomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::Protocol::RoomInfo* room_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class RoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.RoomInfo) */ {
 public:
  inline RoomInfo() : RoomInfo(nullptr) {}
  ~RoomInfo() override;
  explicit PROTOBUF_CONSTEXPR RoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomInfo(const RoomInfo& from);
  RoomInfo(RoomInfo&& from) noexcept
    : RoomInfo() {
    *this = ::std::move(from);
  }

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomInfo& operator=(RoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomInfo*>(
               &_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RoomInfo& a, RoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomInfo& from) {
    RoomInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.RoomInfo";
  }
  protected:
  explicit RoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 4,
    kRoomIdFieldNumber = 1,
    kCurrentCountFieldNumber = 2,
    kMaxCountFieldNumber = 3,
  };
  // repeated .Protocol.PlayerInfo players = 4;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::PlayerInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
      mutable_players();
  private:
  const ::Protocol::PlayerInfo& _internal_players(int index) const;
  ::Protocol::PlayerInfo* _internal_add_players();
  public:
  const ::Protocol::PlayerInfo& players(int index) const;
  ::Protocol::PlayerInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
      players() const;

  // uint64 roomId = 1;
  void clear_roomid();
  uint64_t roomid() const;
  void set_roomid(uint64_t value);
  private:
  uint64_t _internal_roomid() const;
  void _internal_set_roomid(uint64_t value);
  public:

  // uint32 currentCount = 2;
  void clear_currentcount();
  uint32_t currentcount() const;
  void set_currentcount(uint32_t value);
  private:
  uint32_t _internal_currentcount() const;
  void _internal_set_currentcount(uint32_t value);
  public:

  // uint32 maxCount = 3;
  void clear_maxcount();
  uint32_t maxcount() const;
  void set_maxcount(uint32_t value);
  private:
  uint32_t _internal_maxcount() const;
  void _internal_set_maxcount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.RoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo > players_;
    uint64_t roomid_;
    uint32_t currentcount_;
    uint32_t maxcount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  explicit PROTOBUF_CONSTEXPR PlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerInfo& from) {
    PlayerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // string nickname = 2;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // uint64 playerId = 1;
  void clear_playerid();
  uint64_t playerid() const;
  void set_playerid(uint64_t value);
  private:
  uint64_t _internal_playerid() const;
  void _internal_set_playerid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    uint64_t playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class EnterGameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.EnterGameRequest) */ {
 public:
  inline EnterGameRequest() : EnterGameRequest(nullptr) {}
  ~EnterGameRequest() override;
  explicit PROTOBUF_CONSTEXPR EnterGameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnterGameRequest(const EnterGameRequest& from);
  EnterGameRequest(EnterGameRequest&& from) noexcept
    : EnterGameRequest() {
    *this = ::std::move(from);
  }

  inline EnterGameRequest& operator=(const EnterGameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterGameRequest& operator=(EnterGameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnterGameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnterGameRequest* internal_default_instance() {
    return reinterpret_cast<const EnterGameRequest*>(
               &_EnterGameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EnterGameRequest& a, EnterGameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterGameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterGameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnterGameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnterGameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnterGameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnterGameRequest& from) {
    EnterGameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterGameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.EnterGameRequest";
  }
  protected:
  explicit EnterGameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActorIdFieldNumber = 1,
  };
  // uint64 actor_id = 1;
  void clear_actor_id();
  uint64_t actor_id() const;
  void set_actor_id(uint64_t value);
  private:
  uint64_t _internal_actor_id() const;
  void _internal_set_actor_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.EnterGameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t actor_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class EnterGameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.EnterGameResponse) */ {
 public:
  inline EnterGameResponse() : EnterGameResponse(nullptr) {}
  ~EnterGameResponse() override;
  explicit PROTOBUF_CONSTEXPR EnterGameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnterGameResponse(const EnterGameResponse& from);
  EnterGameResponse(EnterGameResponse&& from) noexcept
    : EnterGameResponse() {
    *this = ::std::move(from);
  }

  inline EnterGameResponse& operator=(const EnterGameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterGameResponse& operator=(EnterGameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnterGameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnterGameResponse* internal_default_instance() {
    return reinterpret_cast<const EnterGameResponse*>(
               &_EnterGameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EnterGameResponse& a, EnterGameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterGameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterGameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnterGameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnterGameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EnterGameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EnterGameResponse& from) {
    EnterGameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterGameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.EnterGameResponse";
  }
  protected:
  explicit EnterGameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.EnterGameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class WorldStateUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.WorldStateUpdate) */ {
 public:
  inline WorldStateUpdate() : WorldStateUpdate(nullptr) {}
  ~WorldStateUpdate() override;
  explicit PROTOBUF_CONSTEXPR WorldStateUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorldStateUpdate(const WorldStateUpdate& from);
  WorldStateUpdate(WorldStateUpdate&& from) noexcept
    : WorldStateUpdate() {
    *this = ::std::move(from);
  }

  inline WorldStateUpdate& operator=(const WorldStateUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldStateUpdate& operator=(WorldStateUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldStateUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorldStateUpdate* internal_default_instance() {
    return reinterpret_cast<const WorldStateUpdate*>(
               &_WorldStateUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(WorldStateUpdate& a, WorldStateUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(WorldStateUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldStateUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldStateUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorldStateUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorldStateUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorldStateUpdate& from) {
    WorldStateUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorldStateUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.WorldStateUpdate";
  }
  protected:
  explicit WorldStateUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActorsFieldNumber = 1,
  };
  // repeated .Protocol.ActorInfo actors = 1;
  int actors_size() const;
  private:
  int _internal_actors_size() const;
  public:
  void clear_actors();
  ::Protocol::ActorInfo* mutable_actors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ActorInfo >*
      mutable_actors();
  private:
  const ::Protocol::ActorInfo& _internal_actors(int index) const;
  ::Protocol::ActorInfo* _internal_add_actors();
  public:
  const ::Protocol::ActorInfo& actors(int index) const;
  ::Protocol::ActorInfo* add_actors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ActorInfo >&
      actors() const;

  // @@protoc_insertion_point(class_scope:Protocol.WorldStateUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ActorInfo > actors_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class PlayerMoveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerMoveRequest) */ {
 public:
  inline PlayerMoveRequest() : PlayerMoveRequest(nullptr) {}
  ~PlayerMoveRequest() override;
  explicit PROTOBUF_CONSTEXPR PlayerMoveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerMoveRequest(const PlayerMoveRequest& from);
  PlayerMoveRequest(PlayerMoveRequest&& from) noexcept
    : PlayerMoveRequest() {
    *this = ::std::move(from);
  }

  inline PlayerMoveRequest& operator=(const PlayerMoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMoveRequest& operator=(PlayerMoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerMoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerMoveRequest* internal_default_instance() {
    return reinterpret_cast<const PlayerMoveRequest*>(
               &_PlayerMoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PlayerMoveRequest& a, PlayerMoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerMoveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerMoveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerMoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerMoveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerMoveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerMoveRequest& from) {
    PlayerMoveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerMoveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerMoveRequest";
  }
  protected:
  explicit PlayerMoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewPositionFieldNumber = 2,
    kActorIdFieldNumber = 1,
    kRotationFieldNumber = 3,
  };
  // .Protocol.Vector3 new_position = 2;
  bool has_new_position() const;
  private:
  bool _internal_has_new_position() const;
  public:
  void clear_new_position();
  const ::Protocol::Vector3& new_position() const;
  PROTOBUF_NODISCARD ::Protocol::Vector3* release_new_position();
  ::Protocol::Vector3* mutable_new_position();
  void set_allocated_new_position(::Protocol::Vector3* new_position);
  private:
  const ::Protocol::Vector3& _internal_new_position() const;
  ::Protocol::Vector3* _internal_mutable_new_position();
  public:
  void unsafe_arena_set_allocated_new_position(
      ::Protocol::Vector3* new_position);
  ::Protocol::Vector3* unsafe_arena_release_new_position();

  // uint64 actor_id = 1;
  void clear_actor_id();
  uint64_t actor_id() const;
  void set_actor_id(uint64_t value);
  private:
  uint64_t _internal_actor_id() const;
  void _internal_set_actor_id(uint64_t value);
  public:

  // float rotation = 3;
  void clear_rotation();
  float rotation() const;
  void set_rotation(float value);
  private:
  float _internal_rotation() const;
  void _internal_set_rotation(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerMoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::Vector3* new_position_;
    uint64_t actor_id_;
    float rotation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class PlayerMoveResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerMoveResponse) */ {
 public:
  inline PlayerMoveResponse() : PlayerMoveResponse(nullptr) {}
  ~PlayerMoveResponse() override;
  explicit PROTOBUF_CONSTEXPR PlayerMoveResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerMoveResponse(const PlayerMoveResponse& from);
  PlayerMoveResponse(PlayerMoveResponse&& from) noexcept
    : PlayerMoveResponse() {
    *this = ::std::move(from);
  }

  inline PlayerMoveResponse& operator=(const PlayerMoveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMoveResponse& operator=(PlayerMoveResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerMoveResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerMoveResponse* internal_default_instance() {
    return reinterpret_cast<const PlayerMoveResponse*>(
               &_PlayerMoveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PlayerMoveResponse& a, PlayerMoveResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerMoveResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerMoveResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerMoveResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerMoveResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerMoveResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerMoveResponse& from) {
    PlayerMoveResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerMoveResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerMoveResponse";
  }
  protected:
  explicit PlayerMoveResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewPositionFieldNumber = 2,
    kActorIdFieldNumber = 1,
    kRotationFieldNumber = 3,
  };
  // .Protocol.Vector3 new_position = 2;
  bool has_new_position() const;
  private:
  bool _internal_has_new_position() const;
  public:
  void clear_new_position();
  const ::Protocol::Vector3& new_position() const;
  PROTOBUF_NODISCARD ::Protocol::Vector3* release_new_position();
  ::Protocol::Vector3* mutable_new_position();
  void set_allocated_new_position(::Protocol::Vector3* new_position);
  private:
  const ::Protocol::Vector3& _internal_new_position() const;
  ::Protocol::Vector3* _internal_mutable_new_position();
  public:
  void unsafe_arena_set_allocated_new_position(
      ::Protocol::Vector3* new_position);
  ::Protocol::Vector3* unsafe_arena_release_new_position();

  // uint64 actor_id = 1;
  void clear_actor_id();
  uint64_t actor_id() const;
  void set_actor_id(uint64_t value);
  private:
  uint64_t _internal_actor_id() const;
  void _internal_set_actor_id(uint64_t value);
  public:

  // float rotation = 3;
  void clear_rotation();
  float rotation() const;
  void set_rotation(float value);
  private:
  float _internal_rotation() const;
  void _internal_set_rotation(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerMoveResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::Vector3* new_position_;
    uint64_t actor_id_;
    float rotation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class ChatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ChatRequest) */ {
 public:
  inline ChatRequest() : ChatRequest(nullptr) {}
  ~ChatRequest() override;
  explicit PROTOBUF_CONSTEXPR ChatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatRequest(const ChatRequest& from);
  ChatRequest(ChatRequest&& from) noexcept
    : ChatRequest() {
    *this = ::std::move(from);
  }

  inline ChatRequest& operator=(const ChatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatRequest& operator=(ChatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatRequest* internal_default_instance() {
    return reinterpret_cast<const ChatRequest*>(
               &_ChatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ChatRequest& a, ChatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatRequest& from) {
    ChatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ChatRequest";
  }
  protected:
  explicit ChatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSenderIdFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint64 sender_id = 1;
  void clear_sender_id();
  uint64_t sender_id() const;
  void set_sender_id(uint64_t value);
  private:
  uint64_t _internal_sender_id() const;
  void _internal_set_sender_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ChatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint64_t sender_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class ChatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ChatResponse) */ {
 public:
  inline ChatResponse() : ChatResponse(nullptr) {}
  ~ChatResponse() override;
  explicit PROTOBUF_CONSTEXPR ChatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatResponse(const ChatResponse& from);
  ChatResponse(ChatResponse&& from) noexcept
    : ChatResponse() {
    *this = ::std::move(from);
  }

  inline ChatResponse& operator=(const ChatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatResponse& operator=(ChatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatResponse* internal_default_instance() {
    return reinterpret_cast<const ChatResponse*>(
               &_ChatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ChatResponse& a, ChatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatResponse& from) {
    ChatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ChatResponse";
  }
  protected:
  explicit ChatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSenderIdFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint64 sender_id = 1;
  void clear_sender_id();
  uint64_t sender_id() const;
  void set_sender_id(uint64_t value);
  private:
  uint64_t _internal_sender_id() const;
  void _internal_set_sender_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ChatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint64_t sender_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class ActionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ActionRequest) */ {
 public:
  inline ActionRequest() : ActionRequest(nullptr) {}
  ~ActionRequest() override;
  explicit PROTOBUF_CONSTEXPR ActionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionRequest(const ActionRequest& from);
  ActionRequest(ActionRequest&& from) noexcept
    : ActionRequest() {
    *this = ::std::move(from);
  }

  inline ActionRequest& operator=(const ActionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionRequest& operator=(ActionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionRequest* internal_default_instance() {
    return reinterpret_cast<const ActionRequest*>(
               &_ActionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ActionRequest& a, ActionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionRequest& from) {
    ActionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ActionRequest";
  }
  protected:
  explicit ActionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetIdsFieldNumber = 3,
    kActionIdFieldNumber = 2,
    kExtraDataFieldNumber = 4,
    kActorIdFieldNumber = 1,
  };
  // repeated uint64 target_ids = 3;
  int target_ids_size() const;
  private:
  int _internal_target_ids_size() const;
  public:
  void clear_target_ids();
  private:
  uint64_t _internal_target_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_target_ids() const;
  void _internal_add_target_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_target_ids();
  public:
  uint64_t target_ids(int index) const;
  void set_target_ids(int index, uint64_t value);
  void add_target_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      target_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_target_ids();

  // string action_id = 2;
  void clear_action_id();
  const std::string& action_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action_id();
  PROTOBUF_NODISCARD std::string* release_action_id();
  void set_allocated_action_id(std::string* action_id);
  private:
  const std::string& _internal_action_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_id(const std::string& value);
  std::string* _internal_mutable_action_id();
  public:

  // string extra_data = 4;
  void clear_extra_data();
  const std::string& extra_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra_data();
  PROTOBUF_NODISCARD std::string* release_extra_data();
  void set_allocated_extra_data(std::string* extra_data);
  private:
  const std::string& _internal_extra_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra_data(const std::string& value);
  std::string* _internal_mutable_extra_data();
  public:

  // uint64 actor_id = 1;
  void clear_actor_id();
  uint64_t actor_id() const;
  void set_actor_id(uint64_t value);
  private:
  uint64_t _internal_actor_id() const;
  void _internal_set_actor_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ActionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > target_ids_;
    mutable std::atomic<int> _target_ids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_data_;
    uint64_t actor_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class ActionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ActionResponse) */ {
 public:
  inline ActionResponse() : ActionResponse(nullptr) {}
  ~ActionResponse() override;
  explicit PROTOBUF_CONSTEXPR ActionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ActionResponse(const ActionResponse& from);
  ActionResponse(ActionResponse&& from) noexcept
    : ActionResponse() {
    *this = ::std::move(from);
  }

  inline ActionResponse& operator=(const ActionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActionResponse& operator=(ActionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActionResponse* internal_default_instance() {
    return reinterpret_cast<const ActionResponse*>(
               &_ActionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ActionResponse& a, ActionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ActionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ActionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ActionResponse& from) {
    ActionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ActionResponse";
  }
  protected:
  explicit ActionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAffectedTargetsFieldNumber = 4,
    kResultMessageFieldNumber = 2,
    kActionIdFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // repeated uint64 affected_targets = 4;
  int affected_targets_size() const;
  private:
  int _internal_affected_targets_size() const;
  public:
  void clear_affected_targets();
  private:
  uint64_t _internal_affected_targets(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_affected_targets() const;
  void _internal_add_affected_targets(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_affected_targets();
  public:
  uint64_t affected_targets(int index) const;
  void set_affected_targets(int index, uint64_t value);
  void add_affected_targets(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      affected_targets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_affected_targets();

  // string result_message = 2;
  void clear_result_message();
  const std::string& result_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result_message();
  PROTOBUF_NODISCARD std::string* release_result_message();
  void set_allocated_result_message(std::string* result_message);
  private:
  const std::string& _internal_result_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result_message(const std::string& value);
  std::string* _internal_mutable_result_message();
  public:

  // string action_id = 3;
  void clear_action_id();
  const std::string& action_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action_id();
  PROTOBUF_NODISCARD std::string* release_action_id();
  void set_allocated_action_id(std::string* action_id);
  private:
  const std::string& _internal_action_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_id(const std::string& value);
  std::string* _internal_mutable_action_id();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ActionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > affected_targets_;
    mutable std::atomic<int> _affected_targets_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_id_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoginRequest

// string userNickname = 1;
inline void LoginRequest::clear_usernickname() {
  _impl_.usernickname_.ClearToEmpty();
}
inline const std::string& LoginRequest::usernickname() const {
  // @@protoc_insertion_point(field_get:Protocol.LoginRequest.userNickname)
  return _internal_usernickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_usernickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.usernickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.LoginRequest.userNickname)
}
inline std::string* LoginRequest::mutable_usernickname() {
  std::string* _s = _internal_mutable_usernickname();
  // @@protoc_insertion_point(field_mutable:Protocol.LoginRequest.userNickname)
  return _s;
}
inline const std::string& LoginRequest::_internal_usernickname() const {
  return _impl_.usernickname_.Get();
}
inline void LoginRequest::_internal_set_usernickname(const std::string& value) {
  
  _impl_.usernickname_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_usernickname() {
  
  return _impl_.usernickname_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_usernickname() {
  // @@protoc_insertion_point(field_release:Protocol.LoginRequest.userNickname)
  return _impl_.usernickname_.Release();
}
inline void LoginRequest::set_allocated_usernickname(std::string* usernickname) {
  if (usernickname != nullptr) {
    
  } else {
    
  }
  _impl_.usernickname_.SetAllocated(usernickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.usernickname_.IsDefault()) {
    _impl_.usernickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.LoginRequest.userNickname)
}

// -------------------------------------------------------------------

// LoginResponse

// bool success = 1;
inline void LoginResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool LoginResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool LoginResponse::success() const {
  // @@protoc_insertion_point(field_get:Protocol.LoginResponse.success)
  return _internal_success();
}
inline void LoginResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void LoginResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.LoginResponse.success)
}

// string error_message = 2;
inline void LoginResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& LoginResponse::error_message() const {
  // @@protoc_insertion_point(field_get:Protocol.LoginResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.LoginResponse.error_message)
}
inline std::string* LoginResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:Protocol.LoginResponse.error_message)
  return _s;
}
inline const std::string& LoginResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void LoginResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:Protocol.LoginResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void LoginResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.LoginResponse.error_message)
}

// uint32 playerID = 3;
inline void LoginResponse::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t LoginResponse::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t LoginResponse::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.LoginResponse.playerID)
  return _internal_playerid();
}
inline void LoginResponse::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void LoginResponse::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.LoginResponse.playerID)
}

// string userNickname = 4;
inline void LoginResponse::clear_usernickname() {
  _impl_.usernickname_.ClearToEmpty();
}
inline const std::string& LoginResponse::usernickname() const {
  // @@protoc_insertion_point(field_get:Protocol.LoginResponse.userNickname)
  return _internal_usernickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_usernickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.usernickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.LoginResponse.userNickname)
}
inline std::string* LoginResponse::mutable_usernickname() {
  std::string* _s = _internal_mutable_usernickname();
  // @@protoc_insertion_point(field_mutable:Protocol.LoginResponse.userNickname)
  return _s;
}
inline const std::string& LoginResponse::_internal_usernickname() const {
  return _impl_.usernickname_.Get();
}
inline void LoginResponse::_internal_set_usernickname(const std::string& value) {
  
  _impl_.usernickname_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_usernickname() {
  
  return _impl_.usernickname_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_usernickname() {
  // @@protoc_insertion_point(field_release:Protocol.LoginResponse.userNickname)
  return _impl_.usernickname_.Release();
}
inline void LoginResponse::set_allocated_usernickname(std::string* usernickname) {
  if (usernickname != nullptr) {
    
  } else {
    
  }
  _impl_.usernickname_.SetAllocated(usernickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.usernickname_.IsDefault()) {
    _impl_.usernickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.LoginResponse.userNickname)
}

// -------------------------------------------------------------------

// CreateRoomRequest

// uint64 creatorId = 1;
inline void CreateRoomRequest::clear_creatorid() {
  _impl_.creatorid_ = uint64_t{0u};
}
inline uint64_t CreateRoomRequest::_internal_creatorid() const {
  return _impl_.creatorid_;
}
inline uint64_t CreateRoomRequest::creatorid() const {
  // @@protoc_insertion_point(field_get:Protocol.CreateRoomRequest.creatorId)
  return _internal_creatorid();
}
inline void CreateRoomRequest::_internal_set_creatorid(uint64_t value) {
  
  _impl_.creatorid_ = value;
}
inline void CreateRoomRequest::set_creatorid(uint64_t value) {
  _internal_set_creatorid(value);
  // @@protoc_insertion_point(field_set:Protocol.CreateRoomRequest.creatorId)
}

// -------------------------------------------------------------------

// CreateRoomResponse

// bool success = 1;
inline void CreateRoomResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool CreateRoomResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool CreateRoomResponse::success() const {
  // @@protoc_insertion_point(field_get:Protocol.CreateRoomResponse.success)
  return _internal_success();
}
inline void CreateRoomResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void CreateRoomResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.CreateRoomResponse.success)
}

// string error = 2;
inline void CreateRoomResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& CreateRoomResponse::error() const {
  // @@protoc_insertion_point(field_get:Protocol.CreateRoomResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoomResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CreateRoomResponse.error)
}
inline std::string* CreateRoomResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:Protocol.CreateRoomResponse.error)
  return _s;
}
inline const std::string& CreateRoomResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void CreateRoomResponse::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoomResponse::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoomResponse::release_error() {
  // @@protoc_insertion_point(field_release:Protocol.CreateRoomResponse.error)
  return _impl_.error_.Release();
}
inline void CreateRoomResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CreateRoomResponse.error)
}

// uint64 roomId = 3;
inline void CreateRoomResponse::clear_roomid() {
  _impl_.roomid_ = uint64_t{0u};
}
inline uint64_t CreateRoomResponse::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint64_t CreateRoomResponse::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.CreateRoomResponse.roomId)
  return _internal_roomid();
}
inline void CreateRoomResponse::_internal_set_roomid(uint64_t value) {
  
  _impl_.roomid_ = value;
}
inline void CreateRoomResponse::set_roomid(uint64_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.CreateRoomResponse.roomId)
}

// -------------------------------------------------------------------

// ListRoomsRequest

// -------------------------------------------------------------------

// ListRoomsResponse

// repeated .Protocol.RoomInfo rooms = 1;
inline int ListRoomsResponse::_internal_rooms_size() const {
  return _impl_.rooms_.size();
}
inline int ListRoomsResponse::rooms_size() const {
  return _internal_rooms_size();
}
inline void ListRoomsResponse::clear_rooms() {
  _impl_.rooms_.Clear();
}
inline ::Protocol::RoomInfo* ListRoomsResponse::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.ListRoomsResponse.rooms)
  return _impl_.rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >*
ListRoomsResponse::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.ListRoomsResponse.rooms)
  return &_impl_.rooms_;
}
inline const ::Protocol::RoomInfo& ListRoomsResponse::_internal_rooms(int index) const {
  return _impl_.rooms_.Get(index);
}
inline const ::Protocol::RoomInfo& ListRoomsResponse::rooms(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.ListRoomsResponse.rooms)
  return _internal_rooms(index);
}
inline ::Protocol::RoomInfo* ListRoomsResponse::_internal_add_rooms() {
  return _impl_.rooms_.Add();
}
inline ::Protocol::RoomInfo* ListRoomsResponse::add_rooms() {
  ::Protocol::RoomInfo* _add = _internal_add_rooms();
  // @@protoc_insertion_point(field_add:Protocol.ListRoomsResponse.rooms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >&
ListRoomsResponse::rooms() const {
  // @@protoc_insertion_point(field_list:Protocol.ListRoomsResponse.rooms)
  return _impl_.rooms_;
}

// -------------------------------------------------------------------

// JoinRoomRequest

// uint64 playerId = 1;
inline void JoinRoomRequest::clear_playerid() {
  _impl_.playerid_ = uint64_t{0u};
}
inline uint64_t JoinRoomRequest::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint64_t JoinRoomRequest::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.JoinRoomRequest.playerId)
  return _internal_playerid();
}
inline void JoinRoomRequest::_internal_set_playerid(uint64_t value) {
  
  _impl_.playerid_ = value;
}
inline void JoinRoomRequest::set_playerid(uint64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.JoinRoomRequest.playerId)
}

// uint64 roomId = 2;
inline void JoinRoomRequest::clear_roomid() {
  _impl_.roomid_ = uint64_t{0u};
}
inline uint64_t JoinRoomRequest::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint64_t JoinRoomRequest::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.JoinRoomRequest.roomId)
  return _internal_roomid();
}
inline void JoinRoomRequest::_internal_set_roomid(uint64_t value) {
  
  _impl_.roomid_ = value;
}
inline void JoinRoomRequest::set_roomid(uint64_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.JoinRoomRequest.roomId)
}

// -------------------------------------------------------------------

// JoinRoomResponse

// bool success = 1;
inline void JoinRoomResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool JoinRoomResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool JoinRoomResponse::success() const {
  // @@protoc_insertion_point(field_get:Protocol.JoinRoomResponse.success)
  return _internal_success();
}
inline void JoinRoomResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void JoinRoomResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.JoinRoomResponse.success)
}

// string error = 2;
inline void JoinRoomResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& JoinRoomResponse::error() const {
  // @@protoc_insertion_point(field_get:Protocol.JoinRoomResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinRoomResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.JoinRoomResponse.error)
}
inline std::string* JoinRoomResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:Protocol.JoinRoomResponse.error)
  return _s;
}
inline const std::string& JoinRoomResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void JoinRoomResponse::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinRoomResponse::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinRoomResponse::release_error() {
  // @@protoc_insertion_point(field_release:Protocol.JoinRoomResponse.error)
  return _impl_.error_.Release();
}
inline void JoinRoomResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.JoinRoomResponse.error)
}

// .Protocol.RoomInfo room = 3;
inline bool JoinRoomResponse::_internal_has_room() const {
  return this != internal_default_instance() && _impl_.room_ != nullptr;
}
inline bool JoinRoomResponse::has_room() const {
  return _internal_has_room();
}
inline void JoinRoomResponse::clear_room() {
  if (GetArenaForAllocation() == nullptr && _impl_.room_ != nullptr) {
    delete _impl_.room_;
  }
  _impl_.room_ = nullptr;
}
inline const ::Protocol::RoomInfo& JoinRoomResponse::_internal_room() const {
  const ::Protocol::RoomInfo* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::RoomInfo&>(
      ::Protocol::_RoomInfo_default_instance_);
}
inline const ::Protocol::RoomInfo& JoinRoomResponse::room() const {
  // @@protoc_insertion_point(field_get:Protocol.JoinRoomResponse.room)
  return _internal_room();
}
inline void JoinRoomResponse::unsafe_arena_set_allocated_room(
    ::Protocol::RoomInfo* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = room;
  if (room) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.JoinRoomResponse.room)
}
inline ::Protocol::RoomInfo* JoinRoomResponse::release_room() {
  
  ::Protocol::RoomInfo* temp = _impl_.room_;
  _impl_.room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::RoomInfo* JoinRoomResponse::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:Protocol.JoinRoomResponse.room)
  
  ::Protocol::RoomInfo* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::Protocol::RoomInfo* JoinRoomResponse::_internal_mutable_room() {
  
  if (_impl_.room_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::RoomInfo>(GetArenaForAllocation());
    _impl_.room_ = p;
  }
  return _impl_.room_;
}
inline ::Protocol::RoomInfo* JoinRoomResponse::mutable_room() {
  ::Protocol::RoomInfo* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:Protocol.JoinRoomResponse.room)
  return _msg;
}
inline void JoinRoomResponse::set_allocated_room(::Protocol::RoomInfo* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.room_;
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(room);
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.room_ = room;
  // @@protoc_insertion_point(field_set_allocated:Protocol.JoinRoomResponse.room)
}

// -------------------------------------------------------------------

// RoomInfo

// uint64 roomId = 1;
inline void RoomInfo::clear_roomid() {
  _impl_.roomid_ = uint64_t{0u};
}
inline uint64_t RoomInfo::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint64_t RoomInfo::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.RoomInfo.roomId)
  return _internal_roomid();
}
inline void RoomInfo::_internal_set_roomid(uint64_t value) {
  
  _impl_.roomid_ = value;
}
inline void RoomInfo::set_roomid(uint64_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.RoomInfo.roomId)
}

// uint32 currentCount = 2;
inline void RoomInfo::clear_currentcount() {
  _impl_.currentcount_ = 0u;
}
inline uint32_t RoomInfo::_internal_currentcount() const {
  return _impl_.currentcount_;
}
inline uint32_t RoomInfo::currentcount() const {
  // @@protoc_insertion_point(field_get:Protocol.RoomInfo.currentCount)
  return _internal_currentcount();
}
inline void RoomInfo::_internal_set_currentcount(uint32_t value) {
  
  _impl_.currentcount_ = value;
}
inline void RoomInfo::set_currentcount(uint32_t value) {
  _internal_set_currentcount(value);
  // @@protoc_insertion_point(field_set:Protocol.RoomInfo.currentCount)
}

// uint32 maxCount = 3;
inline void RoomInfo::clear_maxcount() {
  _impl_.maxcount_ = 0u;
}
inline uint32_t RoomInfo::_internal_maxcount() const {
  return _impl_.maxcount_;
}
inline uint32_t RoomInfo::maxcount() const {
  // @@protoc_insertion_point(field_get:Protocol.RoomInfo.maxCount)
  return _internal_maxcount();
}
inline void RoomInfo::_internal_set_maxcount(uint32_t value) {
  
  _impl_.maxcount_ = value;
}
inline void RoomInfo::set_maxcount(uint32_t value) {
  _internal_set_maxcount(value);
  // @@protoc_insertion_point(field_set:Protocol.RoomInfo.maxCount)
}

// repeated .Protocol.PlayerInfo players = 4;
inline int RoomInfo::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int RoomInfo::players_size() const {
  return _internal_players_size();
}
inline void RoomInfo::clear_players() {
  _impl_.players_.Clear();
}
inline ::Protocol::PlayerInfo* RoomInfo::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.RoomInfo.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
RoomInfo::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.RoomInfo.players)
  return &_impl_.players_;
}
inline const ::Protocol::PlayerInfo& RoomInfo::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::PlayerInfo& RoomInfo::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.RoomInfo.players)
  return _internal_players(index);
}
inline ::Protocol::PlayerInfo* RoomInfo::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::PlayerInfo* RoomInfo::add_players() {
  ::Protocol::PlayerInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.RoomInfo.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
RoomInfo::players() const {
  // @@protoc_insertion_point(field_list:Protocol.RoomInfo.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// PlayerInfo

// uint64 playerId = 1;
inline void PlayerInfo::clear_playerid() {
  _impl_.playerid_ = uint64_t{0u};
}
inline uint64_t PlayerInfo::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint64_t PlayerInfo::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.playerId)
  return _internal_playerid();
}
inline void PlayerInfo::_internal_set_playerid(uint64_t value) {
  
  _impl_.playerid_ = value;
}
inline void PlayerInfo::set_playerid(uint64_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerInfo.playerId)
}

// string nickname = 2;
inline void PlayerInfo::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& PlayerInfo::nickname() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.PlayerInfo.nickname)
}
inline std::string* PlayerInfo::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.nickname)
  return _s;
}
inline const std::string& PlayerInfo::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void PlayerInfo::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_nickname() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.nickname)
  return _impl_.nickname_.Release();
}
inline void PlayerInfo::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.nickname)
}

// -------------------------------------------------------------------

// EnterGameRequest

// uint64 actor_id = 1;
inline void EnterGameRequest::clear_actor_id() {
  _impl_.actor_id_ = uint64_t{0u};
}
inline uint64_t EnterGameRequest::_internal_actor_id() const {
  return _impl_.actor_id_;
}
inline uint64_t EnterGameRequest::actor_id() const {
  // @@protoc_insertion_point(field_get:Protocol.EnterGameRequest.actor_id)
  return _internal_actor_id();
}
inline void EnterGameRequest::_internal_set_actor_id(uint64_t value) {
  
  _impl_.actor_id_ = value;
}
inline void EnterGameRequest::set_actor_id(uint64_t value) {
  _internal_set_actor_id(value);
  // @@protoc_insertion_point(field_set:Protocol.EnterGameRequest.actor_id)
}

// -------------------------------------------------------------------

// EnterGameResponse

// bool success = 1;
inline void EnterGameResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool EnterGameResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool EnterGameResponse::success() const {
  // @@protoc_insertion_point(field_get:Protocol.EnterGameResponse.success)
  return _internal_success();
}
inline void EnterGameResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void EnterGameResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.EnterGameResponse.success)
}

// string error_message = 2;
inline void EnterGameResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& EnterGameResponse::error_message() const {
  // @@protoc_insertion_point(field_get:Protocol.EnterGameResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EnterGameResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.EnterGameResponse.error_message)
}
inline std::string* EnterGameResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:Protocol.EnterGameResponse.error_message)
  return _s;
}
inline const std::string& EnterGameResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void EnterGameResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* EnterGameResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* EnterGameResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:Protocol.EnterGameResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void EnterGameResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.EnterGameResponse.error_message)
}

// -------------------------------------------------------------------

// WorldStateUpdate

// repeated .Protocol.ActorInfo actors = 1;
inline int WorldStateUpdate::_internal_actors_size() const {
  return _impl_.actors_.size();
}
inline int WorldStateUpdate::actors_size() const {
  return _internal_actors_size();
}
inline ::Protocol::ActorInfo* WorldStateUpdate::mutable_actors(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.WorldStateUpdate.actors)
  return _impl_.actors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ActorInfo >*
WorldStateUpdate::mutable_actors() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.WorldStateUpdate.actors)
  return &_impl_.actors_;
}
inline const ::Protocol::ActorInfo& WorldStateUpdate::_internal_actors(int index) const {
  return _impl_.actors_.Get(index);
}
inline const ::Protocol::ActorInfo& WorldStateUpdate::actors(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.WorldStateUpdate.actors)
  return _internal_actors(index);
}
inline ::Protocol::ActorInfo* WorldStateUpdate::_internal_add_actors() {
  return _impl_.actors_.Add();
}
inline ::Protocol::ActorInfo* WorldStateUpdate::add_actors() {
  ::Protocol::ActorInfo* _add = _internal_add_actors();
  // @@protoc_insertion_point(field_add:Protocol.WorldStateUpdate.actors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ActorInfo >&
WorldStateUpdate::actors() const {
  // @@protoc_insertion_point(field_list:Protocol.WorldStateUpdate.actors)
  return _impl_.actors_;
}

// -------------------------------------------------------------------

// PlayerMoveRequest

// uint64 actor_id = 1;
inline void PlayerMoveRequest::clear_actor_id() {
  _impl_.actor_id_ = uint64_t{0u};
}
inline uint64_t PlayerMoveRequest::_internal_actor_id() const {
  return _impl_.actor_id_;
}
inline uint64_t PlayerMoveRequest::actor_id() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerMoveRequest.actor_id)
  return _internal_actor_id();
}
inline void PlayerMoveRequest::_internal_set_actor_id(uint64_t value) {
  
  _impl_.actor_id_ = value;
}
inline void PlayerMoveRequest::set_actor_id(uint64_t value) {
  _internal_set_actor_id(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerMoveRequest.actor_id)
}

// .Protocol.Vector3 new_position = 2;
inline bool PlayerMoveRequest::_internal_has_new_position() const {
  return this != internal_default_instance() && _impl_.new_position_ != nullptr;
}
inline bool PlayerMoveRequest::has_new_position() const {
  return _internal_has_new_position();
}
inline const ::Protocol::Vector3& PlayerMoveRequest::_internal_new_position() const {
  const ::Protocol::Vector3* p = _impl_.new_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector3&>(
      ::Protocol::_Vector3_default_instance_);
}
inline const ::Protocol::Vector3& PlayerMoveRequest::new_position() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerMoveRequest.new_position)
  return _internal_new_position();
}
inline void PlayerMoveRequest::unsafe_arena_set_allocated_new_position(
    ::Protocol::Vector3* new_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_position_);
  }
  _impl_.new_position_ = new_position;
  if (new_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerMoveRequest.new_position)
}
inline ::Protocol::Vector3* PlayerMoveRequest::release_new_position() {
  
  ::Protocol::Vector3* temp = _impl_.new_position_;
  _impl_.new_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Vector3* PlayerMoveRequest::unsafe_arena_release_new_position() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerMoveRequest.new_position)
  
  ::Protocol::Vector3* temp = _impl_.new_position_;
  _impl_.new_position_ = nullptr;
  return temp;
}
inline ::Protocol::Vector3* PlayerMoveRequest::_internal_mutable_new_position() {
  
  if (_impl_.new_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector3>(GetArenaForAllocation());
    _impl_.new_position_ = p;
  }
  return _impl_.new_position_;
}
inline ::Protocol::Vector3* PlayerMoveRequest::mutable_new_position() {
  ::Protocol::Vector3* _msg = _internal_mutable_new_position();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerMoveRequest.new_position)
  return _msg;
}
inline void PlayerMoveRequest::set_allocated_new_position(::Protocol::Vector3* new_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_position_);
  }
  if (new_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_position));
    if (message_arena != submessage_arena) {
      new_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.new_position_ = new_position;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerMoveRequest.new_position)
}

// float rotation = 3;
inline void PlayerMoveRequest::clear_rotation() {
  _impl_.rotation_ = 0;
}
inline float PlayerMoveRequest::_internal_rotation() const {
  return _impl_.rotation_;
}
inline float PlayerMoveRequest::rotation() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerMoveRequest.rotation)
  return _internal_rotation();
}
inline void PlayerMoveRequest::_internal_set_rotation(float value) {
  
  _impl_.rotation_ = value;
}
inline void PlayerMoveRequest::set_rotation(float value) {
  _internal_set_rotation(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerMoveRequest.rotation)
}

// -------------------------------------------------------------------

// PlayerMoveResponse

// uint64 actor_id = 1;
inline void PlayerMoveResponse::clear_actor_id() {
  _impl_.actor_id_ = uint64_t{0u};
}
inline uint64_t PlayerMoveResponse::_internal_actor_id() const {
  return _impl_.actor_id_;
}
inline uint64_t PlayerMoveResponse::actor_id() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerMoveResponse.actor_id)
  return _internal_actor_id();
}
inline void PlayerMoveResponse::_internal_set_actor_id(uint64_t value) {
  
  _impl_.actor_id_ = value;
}
inline void PlayerMoveResponse::set_actor_id(uint64_t value) {
  _internal_set_actor_id(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerMoveResponse.actor_id)
}

// .Protocol.Vector3 new_position = 2;
inline bool PlayerMoveResponse::_internal_has_new_position() const {
  return this != internal_default_instance() && _impl_.new_position_ != nullptr;
}
inline bool PlayerMoveResponse::has_new_position() const {
  return _internal_has_new_position();
}
inline const ::Protocol::Vector3& PlayerMoveResponse::_internal_new_position() const {
  const ::Protocol::Vector3* p = _impl_.new_position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector3&>(
      ::Protocol::_Vector3_default_instance_);
}
inline const ::Protocol::Vector3& PlayerMoveResponse::new_position() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerMoveResponse.new_position)
  return _internal_new_position();
}
inline void PlayerMoveResponse::unsafe_arena_set_allocated_new_position(
    ::Protocol::Vector3* new_position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_position_);
  }
  _impl_.new_position_ = new_position;
  if (new_position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerMoveResponse.new_position)
}
inline ::Protocol::Vector3* PlayerMoveResponse::release_new_position() {
  
  ::Protocol::Vector3* temp = _impl_.new_position_;
  _impl_.new_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Vector3* PlayerMoveResponse::unsafe_arena_release_new_position() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerMoveResponse.new_position)
  
  ::Protocol::Vector3* temp = _impl_.new_position_;
  _impl_.new_position_ = nullptr;
  return temp;
}
inline ::Protocol::Vector3* PlayerMoveResponse::_internal_mutable_new_position() {
  
  if (_impl_.new_position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector3>(GetArenaForAllocation());
    _impl_.new_position_ = p;
  }
  return _impl_.new_position_;
}
inline ::Protocol::Vector3* PlayerMoveResponse::mutable_new_position() {
  ::Protocol::Vector3* _msg = _internal_mutable_new_position();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerMoveResponse.new_position)
  return _msg;
}
inline void PlayerMoveResponse::set_allocated_new_position(::Protocol::Vector3* new_position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_position_);
  }
  if (new_position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_position));
    if (message_arena != submessage_arena) {
      new_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.new_position_ = new_position;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerMoveResponse.new_position)
}

// float rotation = 3;
inline void PlayerMoveResponse::clear_rotation() {
  _impl_.rotation_ = 0;
}
inline float PlayerMoveResponse::_internal_rotation() const {
  return _impl_.rotation_;
}
inline float PlayerMoveResponse::rotation() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerMoveResponse.rotation)
  return _internal_rotation();
}
inline void PlayerMoveResponse::_internal_set_rotation(float value) {
  
  _impl_.rotation_ = value;
}
inline void PlayerMoveResponse::set_rotation(float value) {
  _internal_set_rotation(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerMoveResponse.rotation)
}

// -------------------------------------------------------------------

// ChatRequest

// uint64 sender_id = 1;
inline void ChatRequest::clear_sender_id() {
  _impl_.sender_id_ = uint64_t{0u};
}
inline uint64_t ChatRequest::_internal_sender_id() const {
  return _impl_.sender_id_;
}
inline uint64_t ChatRequest::sender_id() const {
  // @@protoc_insertion_point(field_get:Protocol.ChatRequest.sender_id)
  return _internal_sender_id();
}
inline void ChatRequest::_internal_set_sender_id(uint64_t value) {
  
  _impl_.sender_id_ = value;
}
inline void ChatRequest::set_sender_id(uint64_t value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:Protocol.ChatRequest.sender_id)
}

// string message = 2;
inline void ChatRequest::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ChatRequest::message() const {
  // @@protoc_insertion_point(field_get:Protocol.ChatRequest.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatRequest::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.ChatRequest.message)
}
inline std::string* ChatRequest::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Protocol.ChatRequest.message)
  return _s;
}
inline const std::string& ChatRequest::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ChatRequest::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatRequest::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatRequest::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.ChatRequest.message)
  return _impl_.message_.Release();
}
inline void ChatRequest::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.ChatRequest.message)
}

// -------------------------------------------------------------------

// ChatResponse

// uint64 sender_id = 1;
inline void ChatResponse::clear_sender_id() {
  _impl_.sender_id_ = uint64_t{0u};
}
inline uint64_t ChatResponse::_internal_sender_id() const {
  return _impl_.sender_id_;
}
inline uint64_t ChatResponse::sender_id() const {
  // @@protoc_insertion_point(field_get:Protocol.ChatResponse.sender_id)
  return _internal_sender_id();
}
inline void ChatResponse::_internal_set_sender_id(uint64_t value) {
  
  _impl_.sender_id_ = value;
}
inline void ChatResponse::set_sender_id(uint64_t value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:Protocol.ChatResponse.sender_id)
}

// string message = 2;
inline void ChatResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ChatResponse::message() const {
  // @@protoc_insertion_point(field_get:Protocol.ChatResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.ChatResponse.message)
}
inline std::string* ChatResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Protocol.ChatResponse.message)
  return _s;
}
inline const std::string& ChatResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ChatResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatResponse::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.ChatResponse.message)
  return _impl_.message_.Release();
}
inline void ChatResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.ChatResponse.message)
}

// -------------------------------------------------------------------

// ActionRequest

// uint64 actor_id = 1;
inline void ActionRequest::clear_actor_id() {
  _impl_.actor_id_ = uint64_t{0u};
}
inline uint64_t ActionRequest::_internal_actor_id() const {
  return _impl_.actor_id_;
}
inline uint64_t ActionRequest::actor_id() const {
  // @@protoc_insertion_point(field_get:Protocol.ActionRequest.actor_id)
  return _internal_actor_id();
}
inline void ActionRequest::_internal_set_actor_id(uint64_t value) {
  
  _impl_.actor_id_ = value;
}
inline void ActionRequest::set_actor_id(uint64_t value) {
  _internal_set_actor_id(value);
  // @@protoc_insertion_point(field_set:Protocol.ActionRequest.actor_id)
}

// string action_id = 2;
inline void ActionRequest::clear_action_id() {
  _impl_.action_id_.ClearToEmpty();
}
inline const std::string& ActionRequest::action_id() const {
  // @@protoc_insertion_point(field_get:Protocol.ActionRequest.action_id)
  return _internal_action_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionRequest::set_action_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.action_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.ActionRequest.action_id)
}
inline std::string* ActionRequest::mutable_action_id() {
  std::string* _s = _internal_mutable_action_id();
  // @@protoc_insertion_point(field_mutable:Protocol.ActionRequest.action_id)
  return _s;
}
inline const std::string& ActionRequest::_internal_action_id() const {
  return _impl_.action_id_.Get();
}
inline void ActionRequest::_internal_set_action_id(const std::string& value) {
  
  _impl_.action_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionRequest::_internal_mutable_action_id() {
  
  return _impl_.action_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionRequest::release_action_id() {
  // @@protoc_insertion_point(field_release:Protocol.ActionRequest.action_id)
  return _impl_.action_id_.Release();
}
inline void ActionRequest::set_allocated_action_id(std::string* action_id) {
  if (action_id != nullptr) {
    
  } else {
    
  }
  _impl_.action_id_.SetAllocated(action_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.action_id_.IsDefault()) {
    _impl_.action_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.ActionRequest.action_id)
}

// repeated uint64 target_ids = 3;
inline int ActionRequest::_internal_target_ids_size() const {
  return _impl_.target_ids_.size();
}
inline int ActionRequest::target_ids_size() const {
  return _internal_target_ids_size();
}
inline void ActionRequest::clear_target_ids() {
  _impl_.target_ids_.Clear();
}
inline uint64_t ActionRequest::_internal_target_ids(int index) const {
  return _impl_.target_ids_.Get(index);
}
inline uint64_t ActionRequest::target_ids(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.ActionRequest.target_ids)
  return _internal_target_ids(index);
}
inline void ActionRequest::set_target_ids(int index, uint64_t value) {
  _impl_.target_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.ActionRequest.target_ids)
}
inline void ActionRequest::_internal_add_target_ids(uint64_t value) {
  _impl_.target_ids_.Add(value);
}
inline void ActionRequest::add_target_ids(uint64_t value) {
  _internal_add_target_ids(value);
  // @@protoc_insertion_point(field_add:Protocol.ActionRequest.target_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ActionRequest::_internal_target_ids() const {
  return _impl_.target_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ActionRequest::target_ids() const {
  // @@protoc_insertion_point(field_list:Protocol.ActionRequest.target_ids)
  return _internal_target_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ActionRequest::_internal_mutable_target_ids() {
  return &_impl_.target_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ActionRequest::mutable_target_ids() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.ActionRequest.target_ids)
  return _internal_mutable_target_ids();
}

// string extra_data = 4;
inline void ActionRequest::clear_extra_data() {
  _impl_.extra_data_.ClearToEmpty();
}
inline const std::string& ActionRequest::extra_data() const {
  // @@protoc_insertion_point(field_get:Protocol.ActionRequest.extra_data)
  return _internal_extra_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionRequest::set_extra_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.extra_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.ActionRequest.extra_data)
}
inline std::string* ActionRequest::mutable_extra_data() {
  std::string* _s = _internal_mutable_extra_data();
  // @@protoc_insertion_point(field_mutable:Protocol.ActionRequest.extra_data)
  return _s;
}
inline const std::string& ActionRequest::_internal_extra_data() const {
  return _impl_.extra_data_.Get();
}
inline void ActionRequest::_internal_set_extra_data(const std::string& value) {
  
  _impl_.extra_data_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionRequest::_internal_mutable_extra_data() {
  
  return _impl_.extra_data_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionRequest::release_extra_data() {
  // @@protoc_insertion_point(field_release:Protocol.ActionRequest.extra_data)
  return _impl_.extra_data_.Release();
}
inline void ActionRequest::set_allocated_extra_data(std::string* extra_data) {
  if (extra_data != nullptr) {
    
  } else {
    
  }
  _impl_.extra_data_.SetAllocated(extra_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.extra_data_.IsDefault()) {
    _impl_.extra_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.ActionRequest.extra_data)
}

// -------------------------------------------------------------------

// ActionResponse

// bool success = 1;
inline void ActionResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ActionResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ActionResponse::success() const {
  // @@protoc_insertion_point(field_get:Protocol.ActionResponse.success)
  return _internal_success();
}
inline void ActionResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ActionResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.ActionResponse.success)
}

// string result_message = 2;
inline void ActionResponse::clear_result_message() {
  _impl_.result_message_.ClearToEmpty();
}
inline const std::string& ActionResponse::result_message() const {
  // @@protoc_insertion_point(field_get:Protocol.ActionResponse.result_message)
  return _internal_result_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionResponse::set_result_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.result_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.ActionResponse.result_message)
}
inline std::string* ActionResponse::mutable_result_message() {
  std::string* _s = _internal_mutable_result_message();
  // @@protoc_insertion_point(field_mutable:Protocol.ActionResponse.result_message)
  return _s;
}
inline const std::string& ActionResponse::_internal_result_message() const {
  return _impl_.result_message_.Get();
}
inline void ActionResponse::_internal_set_result_message(const std::string& value) {
  
  _impl_.result_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionResponse::_internal_mutable_result_message() {
  
  return _impl_.result_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionResponse::release_result_message() {
  // @@protoc_insertion_point(field_release:Protocol.ActionResponse.result_message)
  return _impl_.result_message_.Release();
}
inline void ActionResponse::set_allocated_result_message(std::string* result_message) {
  if (result_message != nullptr) {
    
  } else {
    
  }
  _impl_.result_message_.SetAllocated(result_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.result_message_.IsDefault()) {
    _impl_.result_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.ActionResponse.result_message)
}

// string action_id = 3;
inline void ActionResponse::clear_action_id() {
  _impl_.action_id_.ClearToEmpty();
}
inline const std::string& ActionResponse::action_id() const {
  // @@protoc_insertion_point(field_get:Protocol.ActionResponse.action_id)
  return _internal_action_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ActionResponse::set_action_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.action_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.ActionResponse.action_id)
}
inline std::string* ActionResponse::mutable_action_id() {
  std::string* _s = _internal_mutable_action_id();
  // @@protoc_insertion_point(field_mutable:Protocol.ActionResponse.action_id)
  return _s;
}
inline const std::string& ActionResponse::_internal_action_id() const {
  return _impl_.action_id_.Get();
}
inline void ActionResponse::_internal_set_action_id(const std::string& value) {
  
  _impl_.action_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ActionResponse::_internal_mutable_action_id() {
  
  return _impl_.action_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ActionResponse::release_action_id() {
  // @@protoc_insertion_point(field_release:Protocol.ActionResponse.action_id)
  return _impl_.action_id_.Release();
}
inline void ActionResponse::set_allocated_action_id(std::string* action_id) {
  if (action_id != nullptr) {
    
  } else {
    
  }
  _impl_.action_id_.SetAllocated(action_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.action_id_.IsDefault()) {
    _impl_.action_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.ActionResponse.action_id)
}

// repeated uint64 affected_targets = 4;
inline int ActionResponse::_internal_affected_targets_size() const {
  return _impl_.affected_targets_.size();
}
inline int ActionResponse::affected_targets_size() const {
  return _internal_affected_targets_size();
}
inline void ActionResponse::clear_affected_targets() {
  _impl_.affected_targets_.Clear();
}
inline uint64_t ActionResponse::_internal_affected_targets(int index) const {
  return _impl_.affected_targets_.Get(index);
}
inline uint64_t ActionResponse::affected_targets(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.ActionResponse.affected_targets)
  return _internal_affected_targets(index);
}
inline void ActionResponse::set_affected_targets(int index, uint64_t value) {
  _impl_.affected_targets_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.ActionResponse.affected_targets)
}
inline void ActionResponse::_internal_add_affected_targets(uint64_t value) {
  _impl_.affected_targets_.Add(value);
}
inline void ActionResponse::add_affected_targets(uint64_t value) {
  _internal_add_affected_targets(value);
  // @@protoc_insertion_point(field_add:Protocol.ActionResponse.affected_targets)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ActionResponse::_internal_affected_targets() const {
  return _impl_.affected_targets_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
ActionResponse::affected_targets() const {
  // @@protoc_insertion_point(field_list:Protocol.ActionResponse.affected_targets)
  return _internal_affected_targets();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ActionResponse::_internal_mutable_affected_targets() {
  return &_impl_.affected_targets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
ActionResponse::mutable_affected_targets() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.ActionResponse.affected_targets)
  return _internal_mutable_affected_targets();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
