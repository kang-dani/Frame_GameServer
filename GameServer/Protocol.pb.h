// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
#include "Struct.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class ChatRequest;
struct ChatRequestDefaultTypeInternal;
extern ChatRequestDefaultTypeInternal _ChatRequest_default_instance_;
class ChatResponse;
struct ChatResponseDefaultTypeInternal;
extern ChatResponseDefaultTypeInternal _ChatResponse_default_instance_;
class CreateRoomRequest;
struct CreateRoomRequestDefaultTypeInternal;
extern CreateRoomRequestDefaultTypeInternal _CreateRoomRequest_default_instance_;
class CreateRoomResponse;
struct CreateRoomResponseDefaultTypeInternal;
extern CreateRoomResponseDefaultTypeInternal _CreateRoomResponse_default_instance_;
class GameStartNotification;
struct GameStartNotificationDefaultTypeInternal;
extern GameStartNotificationDefaultTypeInternal _GameStartNotification_default_instance_;
class InitGeneratorStateRequest;
struct InitGeneratorStateRequestDefaultTypeInternal;
extern InitGeneratorStateRequestDefaultTypeInternal _InitGeneratorStateRequest_default_instance_;
class InitMiniGameStateRequest;
struct InitMiniGameStateRequestDefaultTypeInternal;
extern InitMiniGameStateRequestDefaultTypeInternal _InitMiniGameStateRequest_default_instance_;
class InitWorldStateRequest;
struct InitWorldStateRequestDefaultTypeInternal;
extern InitWorldStateRequestDefaultTypeInternal _InitWorldStateRequest_default_instance_;
class JoinRoomRequest;
struct JoinRoomRequestDefaultTypeInternal;
extern JoinRoomRequestDefaultTypeInternal _JoinRoomRequest_default_instance_;
class JoinRoomResponse;
struct JoinRoomResponseDefaultTypeInternal;
extern JoinRoomResponseDefaultTypeInternal _JoinRoomResponse_default_instance_;
class ListRoomsRequest;
struct ListRoomsRequestDefaultTypeInternal;
extern ListRoomsRequestDefaultTypeInternal _ListRoomsRequest_default_instance_;
class ListRoomsResponse;
struct ListRoomsResponseDefaultTypeInternal;
extern ListRoomsResponseDefaultTypeInternal _ListRoomsResponse_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class PlayerFullStateRequest;
struct PlayerFullStateRequestDefaultTypeInternal;
extern PlayerFullStateRequestDefaultTypeInternal _PlayerFullStateRequest_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PlayerMoveRequest;
struct PlayerMoveRequestDefaultTypeInternal;
extern PlayerMoveRequestDefaultTypeInternal _PlayerMoveRequest_default_instance_;
class PlayerReadyRequest;
struct PlayerReadyRequestDefaultTypeInternal;
extern PlayerReadyRequestDefaultTypeInternal _PlayerReadyRequest_default_instance_;
class PlayerReadyResponse;
struct PlayerReadyResponseDefaultTypeInternal;
extern PlayerReadyResponseDefaultTypeInternal _PlayerReadyResponse_default_instance_;
class PlayerRole;
struct PlayerRoleDefaultTypeInternal;
extern PlayerRoleDefaultTypeInternal _PlayerRole_default_instance_;
class PlayersUpdate;
struct PlayersUpdateDefaultTypeInternal;
extern PlayersUpdateDefaultTypeInternal _PlayersUpdate_default_instance_;
class PlayersUpdate_PlayersEntry_DoNotUse;
struct PlayersUpdate_PlayersEntry_DoNotUseDefaultTypeInternal;
extern PlayersUpdate_PlayersEntry_DoNotUseDefaultTypeInternal _PlayersUpdate_PlayersEntry_DoNotUse_default_instance_;
class ReadyInfo;
struct ReadyInfoDefaultTypeInternal;
extern ReadyInfoDefaultTypeInternal _ReadyInfo_default_instance_;
class RoomInfo;
struct RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class UpdateGeneratorState;
struct UpdateGeneratorStateDefaultTypeInternal;
extern UpdateGeneratorStateDefaultTypeInternal _UpdateGeneratorState_default_instance_;
class UpdateMiniGameState;
struct UpdateMiniGameStateDefaultTypeInternal;
extern UpdateMiniGameStateDefaultTypeInternal _UpdateMiniGameState_default_instance_;
class UpdatePlayerState;
struct UpdatePlayerStateDefaultTypeInternal;
extern UpdatePlayerStateDefaultTypeInternal _UpdatePlayerState_default_instance_;
class WorldStateDelta;
struct WorldStateDeltaDefaultTypeInternal;
extern WorldStateDeltaDefaultTypeInternal _WorldStateDelta_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::ChatRequest* Arena::CreateMaybeMessage<::Protocol::ChatRequest>(Arena*);
template<> ::Protocol::ChatResponse* Arena::CreateMaybeMessage<::Protocol::ChatResponse>(Arena*);
template<> ::Protocol::CreateRoomRequest* Arena::CreateMaybeMessage<::Protocol::CreateRoomRequest>(Arena*);
template<> ::Protocol::CreateRoomResponse* Arena::CreateMaybeMessage<::Protocol::CreateRoomResponse>(Arena*);
template<> ::Protocol::GameStartNotification* Arena::CreateMaybeMessage<::Protocol::GameStartNotification>(Arena*);
template<> ::Protocol::InitGeneratorStateRequest* Arena::CreateMaybeMessage<::Protocol::InitGeneratorStateRequest>(Arena*);
template<> ::Protocol::InitMiniGameStateRequest* Arena::CreateMaybeMessage<::Protocol::InitMiniGameStateRequest>(Arena*);
template<> ::Protocol::InitWorldStateRequest* Arena::CreateMaybeMessage<::Protocol::InitWorldStateRequest>(Arena*);
template<> ::Protocol::JoinRoomRequest* Arena::CreateMaybeMessage<::Protocol::JoinRoomRequest>(Arena*);
template<> ::Protocol::JoinRoomResponse* Arena::CreateMaybeMessage<::Protocol::JoinRoomResponse>(Arena*);
template<> ::Protocol::ListRoomsRequest* Arena::CreateMaybeMessage<::Protocol::ListRoomsRequest>(Arena*);
template<> ::Protocol::ListRoomsResponse* Arena::CreateMaybeMessage<::Protocol::ListRoomsResponse>(Arena*);
template<> ::Protocol::LoginRequest* Arena::CreateMaybeMessage<::Protocol::LoginRequest>(Arena*);
template<> ::Protocol::LoginResponse* Arena::CreateMaybeMessage<::Protocol::LoginResponse>(Arena*);
template<> ::Protocol::PlayerFullStateRequest* Arena::CreateMaybeMessage<::Protocol::PlayerFullStateRequest>(Arena*);
template<> ::Protocol::PlayerInfo* Arena::CreateMaybeMessage<::Protocol::PlayerInfo>(Arena*);
template<> ::Protocol::PlayerMoveRequest* Arena::CreateMaybeMessage<::Protocol::PlayerMoveRequest>(Arena*);
template<> ::Protocol::PlayerReadyRequest* Arena::CreateMaybeMessage<::Protocol::PlayerReadyRequest>(Arena*);
template<> ::Protocol::PlayerReadyResponse* Arena::CreateMaybeMessage<::Protocol::PlayerReadyResponse>(Arena*);
template<> ::Protocol::PlayerRole* Arena::CreateMaybeMessage<::Protocol::PlayerRole>(Arena*);
template<> ::Protocol::PlayersUpdate* Arena::CreateMaybeMessage<::Protocol::PlayersUpdate>(Arena*);
template<> ::Protocol::PlayersUpdate_PlayersEntry_DoNotUse* Arena::CreateMaybeMessage<::Protocol::PlayersUpdate_PlayersEntry_DoNotUse>(Arena*);
template<> ::Protocol::ReadyInfo* Arena::CreateMaybeMessage<::Protocol::ReadyInfo>(Arena*);
template<> ::Protocol::RoomInfo* Arena::CreateMaybeMessage<::Protocol::RoomInfo>(Arena*);
template<> ::Protocol::UpdateGeneratorState* Arena::CreateMaybeMessage<::Protocol::UpdateGeneratorState>(Arena*);
template<> ::Protocol::UpdateMiniGameState* Arena::CreateMaybeMessage<::Protocol::UpdateMiniGameState>(Arena*);
template<> ::Protocol::UpdatePlayerState* Arena::CreateMaybeMessage<::Protocol::UpdatePlayerState>(Arena*);
template<> ::Protocol::WorldStateDelta* Arena::CreateMaybeMessage<::Protocol::WorldStateDelta>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNicknameFieldNumber = 1,
  };
  // string userNickname = 1;
  void clear_usernickname();
  const std::string& usernickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_usernickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_usernickname();
  PROTOBUF_NODISCARD std::string* release_usernickname();
  void set_allocated_usernickname(std::string* usernickname);
  private:
  const std::string& _internal_usernickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_usernickname(const std::string& value);
  std::string* _internal_mutable_usernickname();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr usernickname_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kUserNicknameFieldNumber = 4,
    kSuccessFieldNumber = 1,
    kPlayerIDFieldNumber = 3,
  };
  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // string userNickname = 4;
  void clear_usernickname();
  const std::string& usernickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_usernickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_usernickname();
  PROTOBUF_NODISCARD std::string* release_usernickname();
  void set_allocated_usernickname(std::string* usernickname);
  private:
  const std::string& _internal_usernickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_usernickname(const std::string& value);
  std::string* _internal_mutable_usernickname();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // uint32 playerID = 3;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.LoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr usernickname_;
    bool success_;
    uint32_t playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CreateRoomRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.CreateRoomRequest) */ {
 public:
  inline CreateRoomRequest() : CreateRoomRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CreateRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoomRequest(const CreateRoomRequest& from);
  CreateRoomRequest(CreateRoomRequest&& from) noexcept
    : CreateRoomRequest() {
    *this = ::std::move(from);
  }

  inline CreateRoomRequest& operator=(const CreateRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoomRequest& operator=(CreateRoomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoomRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRoomRequest*>(
               &_CreateRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CreateRoomRequest& a, CreateRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRoomRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateRoomRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateRoomRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CreateRoomRequest";
  }
  protected:
  explicit CreateRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.CreateRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class CreateRoomResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.CreateRoomResponse) */ {
 public:
  inline CreateRoomResponse() : CreateRoomResponse(nullptr) {}
  ~CreateRoomResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateRoomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoomResponse(const CreateRoomResponse& from);
  CreateRoomResponse(CreateRoomResponse&& from) noexcept
    : CreateRoomResponse() {
    *this = ::std::move(from);
  }

  inline CreateRoomResponse& operator=(const CreateRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoomResponse& operator=(CreateRoomResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoomResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRoomResponse*>(
               &_CreateRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateRoomResponse& a, CreateRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoomResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoomResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRoomResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRoomResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRoomResponse& from) {
    CreateRoomResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoomResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.CreateRoomResponse";
  }
  protected:
  explicit CreateRoomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kRoomIdFieldNumber = 3,
  };
  // string error = 2;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // uint32 roomId = 3;
  void clear_roomid();
  uint32_t roomid() const;
  void set_roomid(uint32_t value);
  private:
  uint32_t _internal_roomid() const;
  void _internal_set_roomid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.CreateRoomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    bool success_;
    uint32_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class ListRoomsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Protocol.ListRoomsRequest) */ {
 public:
  inline ListRoomsRequest() : ListRoomsRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ListRoomsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRoomsRequest(const ListRoomsRequest& from);
  ListRoomsRequest(ListRoomsRequest&& from) noexcept
    : ListRoomsRequest() {
    *this = ::std::move(from);
  }

  inline ListRoomsRequest& operator=(const ListRoomsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRoomsRequest& operator=(ListRoomsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRoomsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRoomsRequest* internal_default_instance() {
    return reinterpret_cast<const ListRoomsRequest*>(
               &_ListRoomsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ListRoomsRequest& a, ListRoomsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRoomsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRoomsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRoomsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRoomsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ListRoomsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ListRoomsRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ListRoomsRequest";
  }
  protected:
  explicit ListRoomsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Protocol.ListRoomsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class ListRoomsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ListRoomsResponse) */ {
 public:
  inline ListRoomsResponse() : ListRoomsResponse(nullptr) {}
  ~ListRoomsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListRoomsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListRoomsResponse(const ListRoomsResponse& from);
  ListRoomsResponse(ListRoomsResponse&& from) noexcept
    : ListRoomsResponse() {
    *this = ::std::move(from);
  }

  inline ListRoomsResponse& operator=(const ListRoomsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListRoomsResponse& operator=(ListRoomsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListRoomsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListRoomsResponse* internal_default_instance() {
    return reinterpret_cast<const ListRoomsResponse*>(
               &_ListRoomsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListRoomsResponse& a, ListRoomsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListRoomsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListRoomsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListRoomsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListRoomsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListRoomsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListRoomsResponse& from) {
    ListRoomsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListRoomsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ListRoomsResponse";
  }
  protected:
  explicit ListRoomsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsFieldNumber = 1,
  };
  // repeated .Protocol.RoomInfo rooms = 1;
  int rooms_size() const;
  private:
  int _internal_rooms_size() const;
  public:
  void clear_rooms();
  ::Protocol::RoomInfo* mutable_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >*
      mutable_rooms();
  private:
  const ::Protocol::RoomInfo& _internal_rooms(int index) const;
  ::Protocol::RoomInfo* _internal_add_rooms();
  public:
  const ::Protocol::RoomInfo& rooms(int index) const;
  ::Protocol::RoomInfo* add_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >&
      rooms() const;

  // @@protoc_insertion_point(class_scope:Protocol.ListRoomsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo > rooms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class JoinRoomRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.JoinRoomRequest) */ {
 public:
  inline JoinRoomRequest() : JoinRoomRequest(nullptr) {}
  ~JoinRoomRequest() override;
  explicit PROTOBUF_CONSTEXPR JoinRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinRoomRequest(const JoinRoomRequest& from);
  JoinRoomRequest(JoinRoomRequest&& from) noexcept
    : JoinRoomRequest() {
    *this = ::std::move(from);
  }

  inline JoinRoomRequest& operator=(const JoinRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRoomRequest& operator=(JoinRoomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRoomRequest* internal_default_instance() {
    return reinterpret_cast<const JoinRoomRequest*>(
               &_JoinRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(JoinRoomRequest& a, JoinRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRoomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinRoomRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinRoomRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinRoomRequest& from) {
    JoinRoomRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRoomRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.JoinRoomRequest";
  }
  protected:
  explicit JoinRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kRoomIdFieldNumber = 2,
  };
  // uint32 playerId = 1;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // uint32 roomId = 2;
  void clear_roomid();
  uint32_t roomid() const;
  void set_roomid(uint32_t value);
  private:
  uint32_t _internal_roomid() const;
  void _internal_set_roomid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.JoinRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t playerid_;
    uint32_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class JoinRoomResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.JoinRoomResponse) */ {
 public:
  inline JoinRoomResponse() : JoinRoomResponse(nullptr) {}
  ~JoinRoomResponse() override;
  explicit PROTOBUF_CONSTEXPR JoinRoomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinRoomResponse(const JoinRoomResponse& from);
  JoinRoomResponse(JoinRoomResponse&& from) noexcept
    : JoinRoomResponse() {
    *this = ::std::move(from);
  }

  inline JoinRoomResponse& operator=(const JoinRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRoomResponse& operator=(JoinRoomResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRoomResponse* internal_default_instance() {
    return reinterpret_cast<const JoinRoomResponse*>(
               &_JoinRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(JoinRoomResponse& a, JoinRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRoomResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRoomResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinRoomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinRoomResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinRoomResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinRoomResponse& from) {
    JoinRoomResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRoomResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.JoinRoomResponse";
  }
  protected:
  explicit JoinRoomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kRoomFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string error = 2;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .Protocol.RoomInfo room = 3;
  bool has_room() const;
  private:
  bool _internal_has_room() const;
  public:
  void clear_room();
  const ::Protocol::RoomInfo& room() const;
  PROTOBUF_NODISCARD ::Protocol::RoomInfo* release_room();
  ::Protocol::RoomInfo* mutable_room();
  void set_allocated_room(::Protocol::RoomInfo* room);
  private:
  const ::Protocol::RoomInfo& _internal_room() const;
  ::Protocol::RoomInfo* _internal_mutable_room();
  public:
  void unsafe_arena_set_allocated_room(
      ::Protocol::RoomInfo* room);
  ::Protocol::RoomInfo* unsafe_arena_release_room();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.JoinRoomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::Protocol::RoomInfo* room_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class RoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.RoomInfo) */ {
 public:
  inline RoomInfo() : RoomInfo(nullptr) {}
  ~RoomInfo() override;
  explicit PROTOBUF_CONSTEXPR RoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomInfo(const RoomInfo& from);
  RoomInfo(RoomInfo&& from) noexcept
    : RoomInfo() {
    *this = ::std::move(from);
  }

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomInfo& operator=(RoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomInfo*>(
               &_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RoomInfo& a, RoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomInfo& from) {
    RoomInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.RoomInfo";
  }
  protected:
  explicit RoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 6,
    kCreatorNameFieldNumber = 3,
    kRoomIdFieldNumber = 1,
    kCreatorIdFieldNumber = 2,
    kCurrentCountFieldNumber = 4,
    kMaxCountFieldNumber = 5,
  };
  // repeated .Protocol.PlayerInfo players = 6;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::PlayerInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
      mutable_players();
  private:
  const ::Protocol::PlayerInfo& _internal_players(int index) const;
  ::Protocol::PlayerInfo* _internal_add_players();
  public:
  const ::Protocol::PlayerInfo& players(int index) const;
  ::Protocol::PlayerInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
      players() const;

  // string creatorName = 3;
  void clear_creatorname();
  const std::string& creatorname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creatorname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creatorname();
  PROTOBUF_NODISCARD std::string* release_creatorname();
  void set_allocated_creatorname(std::string* creatorname);
  private:
  const std::string& _internal_creatorname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creatorname(const std::string& value);
  std::string* _internal_mutable_creatorname();
  public:

  // uint32 roomId = 1;
  void clear_roomid();
  uint32_t roomid() const;
  void set_roomid(uint32_t value);
  private:
  uint32_t _internal_roomid() const;
  void _internal_set_roomid(uint32_t value);
  public:

  // uint32 creatorId = 2;
  void clear_creatorid();
  uint32_t creatorid() const;
  void set_creatorid(uint32_t value);
  private:
  uint32_t _internal_creatorid() const;
  void _internal_set_creatorid(uint32_t value);
  public:

  // uint32 currentCount = 4;
  void clear_currentcount();
  uint32_t currentcount() const;
  void set_currentcount(uint32_t value);
  private:
  uint32_t _internal_currentcount() const;
  void _internal_set_currentcount(uint32_t value);
  public:

  // uint32 maxCount = 5;
  void clear_maxcount();
  uint32_t maxcount() const;
  void set_maxcount(uint32_t value);
  private:
  uint32_t _internal_maxcount() const;
  void _internal_set_maxcount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.RoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo > players_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creatorname_;
    uint32_t roomid_;
    uint32_t creatorid_;
    uint32_t currentcount_;
    uint32_t maxcount_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  explicit PROTOBUF_CONSTEXPR PlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerInfo& from) {
    PlayerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // string nickname = 2;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // uint32 playerId = 1;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    uint32_t playerid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class PlayersUpdate_PlayersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlayersUpdate_PlayersEntry_DoNotUse, 
    uint32_t, ::Protocol::PlayerInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<PlayersUpdate_PlayersEntry_DoNotUse, 
    uint32_t, ::Protocol::PlayerInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  PlayersUpdate_PlayersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR PlayersUpdate_PlayersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit PlayersUpdate_PlayersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const PlayersUpdate_PlayersEntry_DoNotUse& other);
  static const PlayersUpdate_PlayersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PlayersUpdate_PlayersEntry_DoNotUse*>(&_PlayersUpdate_PlayersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_Protocol_2eproto;
};

// -------------------------------------------------------------------

class PlayersUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayersUpdate) */ {
 public:
  inline PlayersUpdate() : PlayersUpdate(nullptr) {}
  ~PlayersUpdate() override;
  explicit PROTOBUF_CONSTEXPR PlayersUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayersUpdate(const PlayersUpdate& from);
  PlayersUpdate(PlayersUpdate&& from) noexcept
    : PlayersUpdate() {
    *this = ::std::move(from);
  }

  inline PlayersUpdate& operator=(const PlayersUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayersUpdate& operator=(PlayersUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayersUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayersUpdate* internal_default_instance() {
    return reinterpret_cast<const PlayersUpdate*>(
               &_PlayersUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PlayersUpdate& a, PlayersUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayersUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayersUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayersUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayersUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayersUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayersUpdate& from) {
    PlayersUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayersUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayersUpdate";
  }
  protected:
  explicit PlayersUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // map<uint32, .Protocol.PlayerInfo> players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::Protocol::PlayerInfo >&
      _internal_players() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::Protocol::PlayerInfo >*
      _internal_mutable_players();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::Protocol::PlayerInfo >&
      players() const;
  ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::Protocol::PlayerInfo >*
      mutable_players();

  // @@protoc_insertion_point(class_scope:Protocol.PlayersUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        PlayersUpdate_PlayersEntry_DoNotUse,
        uint32_t, ::Protocol::PlayerInfo,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> players_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class PlayerReadyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerReadyRequest) */ {
 public:
  inline PlayerReadyRequest() : PlayerReadyRequest(nullptr) {}
  ~PlayerReadyRequest() override;
  explicit PROTOBUF_CONSTEXPR PlayerReadyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerReadyRequest(const PlayerReadyRequest& from);
  PlayerReadyRequest(PlayerReadyRequest&& from) noexcept
    : PlayerReadyRequest() {
    *this = ::std::move(from);
  }

  inline PlayerReadyRequest& operator=(const PlayerReadyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerReadyRequest& operator=(PlayerReadyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerReadyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerReadyRequest* internal_default_instance() {
    return reinterpret_cast<const PlayerReadyRequest*>(
               &_PlayerReadyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PlayerReadyRequest& a, PlayerReadyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerReadyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerReadyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerReadyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerReadyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerReadyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerReadyRequest& from) {
    PlayerReadyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerReadyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerReadyRequest";
  }
  protected:
  explicit PlayerReadyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsReadyFieldNumber = 2,
  };
  // bool isReady = 2;
  void clear_isready();
  bool isready() const;
  void set_isready(bool value);
  private:
  bool _internal_isready() const;
  void _internal_set_isready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerReadyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool isready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class ReadyInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ReadyInfo) */ {
 public:
  inline ReadyInfo() : ReadyInfo(nullptr) {}
  ~ReadyInfo() override;
  explicit PROTOBUF_CONSTEXPR ReadyInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadyInfo(const ReadyInfo& from);
  ReadyInfo(ReadyInfo&& from) noexcept
    : ReadyInfo() {
    *this = ::std::move(from);
  }

  inline ReadyInfo& operator=(const ReadyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadyInfo& operator=(ReadyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadyInfo* internal_default_instance() {
    return reinterpret_cast<const ReadyInfo*>(
               &_ReadyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ReadyInfo& a, ReadyInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadyInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadyInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadyInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadyInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadyInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadyInfo& from) {
    ReadyInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadyInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ReadyInfo";
  }
  protected:
  explicit ReadyInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kIsReadyFieldNumber = 2,
  };
  // uint32 playerId = 1;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // bool isReady = 2;
  void clear_isready();
  bool isready() const;
  void set_isready(bool value);
  private:
  bool _internal_isready() const;
  void _internal_set_isready(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ReadyInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t playerid_;
    bool isready_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class PlayerReadyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerReadyResponse) */ {
 public:
  inline PlayerReadyResponse() : PlayerReadyResponse(nullptr) {}
  ~PlayerReadyResponse() override;
  explicit PROTOBUF_CONSTEXPR PlayerReadyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerReadyResponse(const PlayerReadyResponse& from);
  PlayerReadyResponse(PlayerReadyResponse&& from) noexcept
    : PlayerReadyResponse() {
    *this = ::std::move(from);
  }

  inline PlayerReadyResponse& operator=(const PlayerReadyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerReadyResponse& operator=(PlayerReadyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerReadyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerReadyResponse* internal_default_instance() {
    return reinterpret_cast<const PlayerReadyResponse*>(
               &_PlayerReadyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PlayerReadyResponse& a, PlayerReadyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerReadyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerReadyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerReadyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerReadyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerReadyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerReadyResponse& from) {
    PlayerReadyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerReadyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerReadyResponse";
  }
  protected:
  explicit PlayerReadyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 4,
    kRoomIdFieldNumber = 1,
  };
  // repeated .Protocol.ReadyInfo players = 4;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::ReadyInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ReadyInfo >*
      mutable_players();
  private:
  const ::Protocol::ReadyInfo& _internal_players(int index) const;
  ::Protocol::ReadyInfo* _internal_add_players();
  public:
  const ::Protocol::ReadyInfo& players(int index) const;
  ::Protocol::ReadyInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ReadyInfo >&
      players() const;

  // uint32 roomId = 1;
  void clear_roomid();
  uint32_t roomid() const;
  void set_roomid(uint32_t value);
  private:
  uint32_t _internal_roomid() const;
  void _internal_set_roomid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerReadyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ReadyInfo > players_;
    uint32_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class GameStartNotification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.GameStartNotification) */ {
 public:
  inline GameStartNotification() : GameStartNotification(nullptr) {}
  ~GameStartNotification() override;
  explicit PROTOBUF_CONSTEXPR GameStartNotification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameStartNotification(const GameStartNotification& from);
  GameStartNotification(GameStartNotification&& from) noexcept
    : GameStartNotification() {
    *this = ::std::move(from);
  }

  inline GameStartNotification& operator=(const GameStartNotification& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameStartNotification& operator=(GameStartNotification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameStartNotification& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameStartNotification* internal_default_instance() {
    return reinterpret_cast<const GameStartNotification*>(
               &_GameStartNotification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GameStartNotification& a, GameStartNotification& b) {
    a.Swap(&b);
  }
  inline void Swap(GameStartNotification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameStartNotification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameStartNotification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameStartNotification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameStartNotification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameStartNotification& from) {
    GameStartNotification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameStartNotification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.GameStartNotification";
  }
  protected:
  explicit GameStartNotification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 2,
    kPlayerRolesFieldNumber = 3,
    kRoomIdFieldNumber = 1,
    kBossTypeFieldNumber = 4,
  };
  // repeated .Protocol.PlayerInfo players = 2;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::PlayerInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
      mutable_players();
  private:
  const ::Protocol::PlayerInfo& _internal_players(int index) const;
  ::Protocol::PlayerInfo* _internal_add_players();
  public:
  const ::Protocol::PlayerInfo& players(int index) const;
  ::Protocol::PlayerInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
      players() const;

  // repeated .Protocol.Role playerRoles = 3;
  int playerroles_size() const;
  private:
  int _internal_playerroles_size() const;
  public:
  void clear_playerroles();
  private:
  ::Protocol::Role _internal_playerroles(int index) const;
  void _internal_add_playerroles(::Protocol::Role value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_playerroles();
  public:
  ::Protocol::Role playerroles(int index) const;
  void set_playerroles(int index, ::Protocol::Role value);
  void add_playerroles(::Protocol::Role value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& playerroles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_playerroles();

  // uint32 roomId = 1;
  void clear_roomid();
  uint32_t roomid() const;
  void set_roomid(uint32_t value);
  private:
  uint32_t _internal_roomid() const;
  void _internal_set_roomid(uint32_t value);
  public:

  // .Protocol.BossType boss_type = 4;
  void clear_boss_type();
  ::Protocol::BossType boss_type() const;
  void set_boss_type(::Protocol::BossType value);
  private:
  ::Protocol::BossType _internal_boss_type() const;
  void _internal_set_boss_type(::Protocol::BossType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.GameStartNotification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo > players_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> playerroles_;
    mutable std::atomic<int> _playerroles_cached_byte_size_;
    uint32_t roomid_;
    int boss_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class PlayerRole final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerRole) */ {
 public:
  inline PlayerRole() : PlayerRole(nullptr) {}
  ~PlayerRole() override;
  explicit PROTOBUF_CONSTEXPR PlayerRole(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerRole(const PlayerRole& from);
  PlayerRole(PlayerRole&& from) noexcept
    : PlayerRole() {
    *this = ::std::move(from);
  }

  inline PlayerRole& operator=(const PlayerRole& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerRole& operator=(PlayerRole&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerRole& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerRole* internal_default_instance() {
    return reinterpret_cast<const PlayerRole*>(
               &_PlayerRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PlayerRole& a, PlayerRole& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerRole* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerRole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerRole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerRole>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerRole& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerRole& from) {
    PlayerRole::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerRole* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerRole";
  }
  protected:
  explicit PlayerRole(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kRoleFieldNumber = 2,
  };
  // uint32 playerId = 1;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // .Protocol.ActorRole role = 2;
  void clear_role();
  ::Protocol::ActorRole role() const;
  void set_role(::Protocol::ActorRole value);
  private:
  ::Protocol::ActorRole _internal_role() const;
  void _internal_set_role(::Protocol::ActorRole value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerRole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t playerid_;
    int role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class PlayerFullStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerFullStateRequest) */ {
 public:
  inline PlayerFullStateRequest() : PlayerFullStateRequest(nullptr) {}
  ~PlayerFullStateRequest() override;
  explicit PROTOBUF_CONSTEXPR PlayerFullStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerFullStateRequest(const PlayerFullStateRequest& from);
  PlayerFullStateRequest(PlayerFullStateRequest&& from) noexcept
    : PlayerFullStateRequest() {
    *this = ::std::move(from);
  }

  inline PlayerFullStateRequest& operator=(const PlayerFullStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerFullStateRequest& operator=(PlayerFullStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerFullStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerFullStateRequest* internal_default_instance() {
    return reinterpret_cast<const PlayerFullStateRequest*>(
               &_PlayerFullStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PlayerFullStateRequest& a, PlayerFullStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerFullStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerFullStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerFullStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerFullStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerFullStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerFullStateRequest& from) {
    PlayerFullStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerFullStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerFullStateRequest";
  }
  protected:
  explicit PlayerFullStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLifeFieldNumber = 2,
    kDeathPlayerFieldNumber = 3,
    kNicknameFieldNumber = 4,
    kEscapeMessageFieldNumber = 15,
    kPositionFieldNumber = 5,
    kScaleFieldNumber = 6,
    kPlayerIdFieldNumber = 1,
    kFacingDirXFieldNumber = 9,
    kFacingDirYFieldNumber = 10,
    kStateTypeFieldNumber = 12,
    kIsJailedFieldNumber = 11,
    kSuccessGeneratorFieldNumber = 13,
    kMiniGameSuccessFieldNumber = 14,
    kMiniGameSparkleFieldNumber = 17,
    kAlphaPlayerFieldNumber = 16,
    kEscapeCodeFieldNumber = 18,
    kHasUpgradedFlashlightFieldNumber = 19,
    kIsLoadingFieldNumber = 20,
    kIsBossFieldNumber = 22,
    kCharacterChoiceFieldNumber = 21,
    kBossTypeFieldNumber = 23,
  };
  // repeated bool life = 2;
  int life_size() const;
  private:
  int _internal_life_size() const;
  public:
  void clear_life();
  private:
  bool _internal_life(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_life() const;
  void _internal_add_life(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_life();
  public:
  bool life(int index) const;
  void set_life(int index, bool value);
  void add_life(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      life() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_life();

  // repeated bool deathPlayer = 3;
  int deathplayer_size() const;
  private:
  int _internal_deathplayer_size() const;
  public:
  void clear_deathplayer();
  private:
  bool _internal_deathplayer(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_deathplayer() const;
  void _internal_add_deathplayer(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_deathplayer();
  public:
  bool deathplayer(int index) const;
  void set_deathplayer(int index, bool value);
  void add_deathplayer(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      deathplayer() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_deathplayer();

  // string nickname = 4;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // string escapeMessage = 15;
  void clear_escapemessage();
  const std::string& escapemessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_escapemessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_escapemessage();
  PROTOBUF_NODISCARD std::string* release_escapemessage();
  void set_allocated_escapemessage(std::string* escapemessage);
  private:
  const std::string& _internal_escapemessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escapemessage(const std::string& value);
  std::string* _internal_mutable_escapemessage();
  public:

  // .Protocol.Vector3 position = 5;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Protocol::Vector3& position() const;
  PROTOBUF_NODISCARD ::Protocol::Vector3* release_position();
  ::Protocol::Vector3* mutable_position();
  void set_allocated_position(::Protocol::Vector3* position);
  private:
  const ::Protocol::Vector3& _internal_position() const;
  ::Protocol::Vector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::Protocol::Vector3* position);
  ::Protocol::Vector3* unsafe_arena_release_position();

  // .Protocol.Vector3 scale = 6;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  const ::Protocol::Vector3& scale() const;
  PROTOBUF_NODISCARD ::Protocol::Vector3* release_scale();
  ::Protocol::Vector3* mutable_scale();
  void set_allocated_scale(::Protocol::Vector3* scale);
  private:
  const ::Protocol::Vector3& _internal_scale() const;
  ::Protocol::Vector3* _internal_mutable_scale();
  public:
  void unsafe_arena_set_allocated_scale(
      ::Protocol::Vector3* scale);
  ::Protocol::Vector3* unsafe_arena_release_scale();

  // uint32 playerId = 1;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // int32 facingDirX = 9;
  void clear_facingdirx();
  int32_t facingdirx() const;
  void set_facingdirx(int32_t value);
  private:
  int32_t _internal_facingdirx() const;
  void _internal_set_facingdirx(int32_t value);
  public:

  // int32 facingDirY = 10;
  void clear_facingdiry();
  int32_t facingdiry() const;
  void set_facingdiry(int32_t value);
  private:
  int32_t _internal_facingdiry() const;
  void _internal_set_facingdiry(int32_t value);
  public:

  // .Protocol.PlayerStateType stateType = 12;
  void clear_statetype();
  ::Protocol::PlayerStateType statetype() const;
  void set_statetype(::Protocol::PlayerStateType value);
  private:
  ::Protocol::PlayerStateType _internal_statetype() const;
  void _internal_set_statetype(::Protocol::PlayerStateType value);
  public:

  // bool isJailed = 11;
  void clear_isjailed();
  bool isjailed() const;
  void set_isjailed(bool value);
  private:
  bool _internal_isjailed() const;
  void _internal_set_isjailed(bool value);
  public:

  // bool successGenerator = 13;
  void clear_successgenerator();
  bool successgenerator() const;
  void set_successgenerator(bool value);
  private:
  bool _internal_successgenerator() const;
  void _internal_set_successgenerator(bool value);
  public:

  // bool miniGameSuccess = 14;
  void clear_minigamesuccess();
  bool minigamesuccess() const;
  void set_minigamesuccess(bool value);
  private:
  bool _internal_minigamesuccess() const;
  void _internal_set_minigamesuccess(bool value);
  public:

  // bool miniGameSparkle = 17;
  void clear_minigamesparkle();
  bool minigamesparkle() const;
  void set_minigamesparkle(bool value);
  private:
  bool _internal_minigamesparkle() const;
  void _internal_set_minigamesparkle(bool value);
  public:

  // float alphaPlayer = 16;
  void clear_alphaplayer();
  float alphaplayer() const;
  void set_alphaplayer(float value);
  private:
  float _internal_alphaplayer() const;
  void _internal_set_alphaplayer(float value);
  public:

  // .Protocol.EscapeType escapeCode = 18;
  void clear_escapecode();
  ::Protocol::EscapeType escapecode() const;
  void set_escapecode(::Protocol::EscapeType value);
  private:
  ::Protocol::EscapeType _internal_escapecode() const;
  void _internal_set_escapecode(::Protocol::EscapeType value);
  public:

  // bool hasUpgradedFlashlight = 19;
  void clear_hasupgradedflashlight();
  bool hasupgradedflashlight() const;
  void set_hasupgradedflashlight(bool value);
  private:
  bool _internal_hasupgradedflashlight() const;
  void _internal_set_hasupgradedflashlight(bool value);
  public:

  // bool isLoading = 20;
  void clear_isloading();
  bool isloading() const;
  void set_isloading(bool value);
  private:
  bool _internal_isloading() const;
  void _internal_set_isloading(bool value);
  public:

  // bool isBoss = 22;
  void clear_isboss();
  bool isboss() const;
  void set_isboss(bool value);
  private:
  bool _internal_isboss() const;
  void _internal_set_isboss(bool value);
  public:

  // uint32 characterChoice = 21;
  void clear_characterchoice();
  uint32_t characterchoice() const;
  void set_characterchoice(uint32_t value);
  private:
  uint32_t _internal_characterchoice() const;
  void _internal_set_characterchoice(uint32_t value);
  public:

  // .Protocol.BossType bossType = 23;
  void clear_bosstype();
  ::Protocol::BossType bosstype() const;
  void set_bosstype(::Protocol::BossType value);
  private:
  ::Protocol::BossType _internal_bosstype() const;
  void _internal_set_bosstype(::Protocol::BossType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerFullStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > life_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > deathplayer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr escapemessage_;
    ::Protocol::Vector3* position_;
    ::Protocol::Vector3* scale_;
    uint32_t playerid_;
    int32_t facingdirx_;
    int32_t facingdiry_;
    int statetype_;
    bool isjailed_;
    bool successgenerator_;
    bool minigamesuccess_;
    bool minigamesparkle_;
    float alphaplayer_;
    int escapecode_;
    bool hasupgradedflashlight_;
    bool isloading_;
    bool isboss_;
    uint32_t characterchoice_;
    int bosstype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class InitGeneratorStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.InitGeneratorStateRequest) */ {
 public:
  inline InitGeneratorStateRequest() : InitGeneratorStateRequest(nullptr) {}
  ~InitGeneratorStateRequest() override;
  explicit PROTOBUF_CONSTEXPR InitGeneratorStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitGeneratorStateRequest(const InitGeneratorStateRequest& from);
  InitGeneratorStateRequest(InitGeneratorStateRequest&& from) noexcept
    : InitGeneratorStateRequest() {
    *this = ::std::move(from);
  }

  inline InitGeneratorStateRequest& operator=(const InitGeneratorStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitGeneratorStateRequest& operator=(InitGeneratorStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitGeneratorStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitGeneratorStateRequest* internal_default_instance() {
    return reinterpret_cast<const InitGeneratorStateRequest*>(
               &_InitGeneratorStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(InitGeneratorStateRequest& a, InitGeneratorStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitGeneratorStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitGeneratorStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitGeneratorStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitGeneratorStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitGeneratorStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitGeneratorStateRequest& from) {
    InitGeneratorStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitGeneratorStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.InitGeneratorStateRequest";
  }
  protected:
  explicit InitGeneratorStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransformFieldNumber = 2,
    kGeneratorIdFieldNumber = 1,
    kIsActivatedFieldNumber = 3,
    kIsSparklingFieldNumber = 4,
    kIsDoneFieldNumber = 5,
    kGeneratorsGageFieldNumber = 6,
  };
  // .Protocol.TransformData transform = 2;
  bool has_transform() const;
  private:
  bool _internal_has_transform() const;
  public:
  void clear_transform();
  const ::Protocol::TransformData& transform() const;
  PROTOBUF_NODISCARD ::Protocol::TransformData* release_transform();
  ::Protocol::TransformData* mutable_transform();
  void set_allocated_transform(::Protocol::TransformData* transform);
  private:
  const ::Protocol::TransformData& _internal_transform() const;
  ::Protocol::TransformData* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::Protocol::TransformData* transform);
  ::Protocol::TransformData* unsafe_arena_release_transform();

  // uint32 generatorId = 1;
  void clear_generatorid();
  uint32_t generatorid() const;
  void set_generatorid(uint32_t value);
  private:
  uint32_t _internal_generatorid() const;
  void _internal_set_generatorid(uint32_t value);
  public:

  // bool isActivated = 3;
  void clear_isactivated();
  bool isactivated() const;
  void set_isactivated(bool value);
  private:
  bool _internal_isactivated() const;
  void _internal_set_isactivated(bool value);
  public:

  // bool isSparkling = 4;
  void clear_issparkling();
  bool issparkling() const;
  void set_issparkling(bool value);
  private:
  bool _internal_issparkling() const;
  void _internal_set_issparkling(bool value);
  public:

  // bool isDone = 5;
  void clear_isdone();
  bool isdone() const;
  void set_isdone(bool value);
  private:
  bool _internal_isdone() const;
  void _internal_set_isdone(bool value);
  public:

  // uint32 generatorsGage = 6;
  void clear_generatorsgage();
  uint32_t generatorsgage() const;
  void set_generatorsgage(uint32_t value);
  private:
  uint32_t _internal_generatorsgage() const;
  void _internal_set_generatorsgage(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.InitGeneratorStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::TransformData* transform_;
    uint32_t generatorid_;
    bool isactivated_;
    bool issparkling_;
    bool isdone_;
    uint32_t generatorsgage_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class InitMiniGameStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.InitMiniGameStateRequest) */ {
 public:
  inline InitMiniGameStateRequest() : InitMiniGameStateRequest(nullptr) {}
  ~InitMiniGameStateRequest() override;
  explicit PROTOBUF_CONSTEXPR InitMiniGameStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitMiniGameStateRequest(const InitMiniGameStateRequest& from);
  InitMiniGameStateRequest(InitMiniGameStateRequest&& from) noexcept
    : InitMiniGameStateRequest() {
    *this = ::std::move(from);
  }

  inline InitMiniGameStateRequest& operator=(const InitMiniGameStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitMiniGameStateRequest& operator=(InitMiniGameStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitMiniGameStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitMiniGameStateRequest* internal_default_instance() {
    return reinterpret_cast<const InitMiniGameStateRequest*>(
               &_InitMiniGameStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(InitMiniGameStateRequest& a, InitMiniGameStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitMiniGameStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitMiniGameStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitMiniGameStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitMiniGameStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitMiniGameStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitMiniGameStateRequest& from) {
    InitMiniGameStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitMiniGameStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.InitMiniGameStateRequest";
  }
  protected:
  explicit InitMiniGameStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransformFieldNumber = 2,
    kMiniGameIdFieldNumber = 1,
    kIsClearedFieldNumber = 3,
    kIsSparklingFieldNumber = 4,
  };
  // .Protocol.TransformData transform = 2;
  bool has_transform() const;
  private:
  bool _internal_has_transform() const;
  public:
  void clear_transform();
  const ::Protocol::TransformData& transform() const;
  PROTOBUF_NODISCARD ::Protocol::TransformData* release_transform();
  ::Protocol::TransformData* mutable_transform();
  void set_allocated_transform(::Protocol::TransformData* transform);
  private:
  const ::Protocol::TransformData& _internal_transform() const;
  ::Protocol::TransformData* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::Protocol::TransformData* transform);
  ::Protocol::TransformData* unsafe_arena_release_transform();

  // uint32 miniGameId = 1;
  void clear_minigameid();
  uint32_t minigameid() const;
  void set_minigameid(uint32_t value);
  private:
  uint32_t _internal_minigameid() const;
  void _internal_set_minigameid(uint32_t value);
  public:

  // bool isCleared = 3;
  void clear_iscleared();
  bool iscleared() const;
  void set_iscleared(bool value);
  private:
  bool _internal_iscleared() const;
  void _internal_set_iscleared(bool value);
  public:

  // bool isSparkling = 4;
  void clear_issparkling();
  bool issparkling() const;
  void set_issparkling(bool value);
  private:
  bool _internal_issparkling() const;
  void _internal_set_issparkling(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.InitMiniGameStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::TransformData* transform_;
    uint32_t minigameid_;
    bool iscleared_;
    bool issparkling_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class InitWorldStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.InitWorldStateRequest) */ {
 public:
  inline InitWorldStateRequest() : InitWorldStateRequest(nullptr) {}
  ~InitWorldStateRequest() override;
  explicit PROTOBUF_CONSTEXPR InitWorldStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitWorldStateRequest(const InitWorldStateRequest& from);
  InitWorldStateRequest(InitWorldStateRequest&& from) noexcept
    : InitWorldStateRequest() {
    *this = ::std::move(from);
  }

  inline InitWorldStateRequest& operator=(const InitWorldStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitWorldStateRequest& operator=(InitWorldStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitWorldStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitWorldStateRequest* internal_default_instance() {
    return reinterpret_cast<const InitWorldStateRequest*>(
               &_InitWorldStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(InitWorldStateRequest& a, InitWorldStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InitWorldStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitWorldStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitWorldStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitWorldStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitWorldStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitWorldStateRequest& from) {
    InitWorldStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitWorldStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.InitWorldStateRequest";
  }
  protected:
  explicit InitWorldStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
    kGeneratorsFieldNumber = 2,
    kMiniGamesFieldNumber = 3,
  };
  // repeated .Protocol.PlayerFullStateRequest players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::PlayerFullStateRequest* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerFullStateRequest >*
      mutable_players();
  private:
  const ::Protocol::PlayerFullStateRequest& _internal_players(int index) const;
  ::Protocol::PlayerFullStateRequest* _internal_add_players();
  public:
  const ::Protocol::PlayerFullStateRequest& players(int index) const;
  ::Protocol::PlayerFullStateRequest* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerFullStateRequest >&
      players() const;

  // repeated .Protocol.InitGeneratorStateRequest generators = 2;
  int generators_size() const;
  private:
  int _internal_generators_size() const;
  public:
  void clear_generators();
  ::Protocol::InitGeneratorStateRequest* mutable_generators(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::InitGeneratorStateRequest >*
      mutable_generators();
  private:
  const ::Protocol::InitGeneratorStateRequest& _internal_generators(int index) const;
  ::Protocol::InitGeneratorStateRequest* _internal_add_generators();
  public:
  const ::Protocol::InitGeneratorStateRequest& generators(int index) const;
  ::Protocol::InitGeneratorStateRequest* add_generators();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::InitGeneratorStateRequest >&
      generators() const;

  // repeated .Protocol.InitMiniGameStateRequest miniGames = 3;
  int minigames_size() const;
  private:
  int _internal_minigames_size() const;
  public:
  void clear_minigames();
  ::Protocol::InitMiniGameStateRequest* mutable_minigames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::InitMiniGameStateRequest >*
      mutable_minigames();
  private:
  const ::Protocol::InitMiniGameStateRequest& _internal_minigames(int index) const;
  ::Protocol::InitMiniGameStateRequest* _internal_add_minigames();
  public:
  const ::Protocol::InitMiniGameStateRequest& minigames(int index) const;
  ::Protocol::InitMiniGameStateRequest* add_minigames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::InitMiniGameStateRequest >&
      minigames() const;

  // @@protoc_insertion_point(class_scope:Protocol.InitWorldStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerFullStateRequest > players_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::InitGeneratorStateRequest > generators_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::InitMiniGameStateRequest > minigames_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class UpdatePlayerState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.UpdatePlayerState) */ {
 public:
  inline UpdatePlayerState() : UpdatePlayerState(nullptr) {}
  ~UpdatePlayerState() override;
  explicit PROTOBUF_CONSTEXPR UpdatePlayerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePlayerState(const UpdatePlayerState& from);
  UpdatePlayerState(UpdatePlayerState&& from) noexcept
    : UpdatePlayerState() {
    *this = ::std::move(from);
  }

  inline UpdatePlayerState& operator=(const UpdatePlayerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePlayerState& operator=(UpdatePlayerState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePlayerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePlayerState* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayerState*>(
               &_UpdatePlayerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UpdatePlayerState& a, UpdatePlayerState& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePlayerState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePlayerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePlayerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdatePlayerState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePlayerState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdatePlayerState& from) {
    UpdatePlayerState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePlayerState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.UpdatePlayerState";
  }
  protected:
  explicit UpdatePlayerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateAnimationFieldNumber = 3,
    kTransformFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
    kStateTypeFieldNumber = 4,
    kIsJailedFieldNumber = 5,
    kFlashlightOnFieldNumber = 6,
    kIsLoadingFieldNumber = 7,
    kMiniGameSuccessFieldNumber = 8,
    kEscapeCodeFieldNumber = 9,
    kAlphaPlayerFieldNumber = 10,
    kFacingDirXFieldNumber = 12,
    kMiniGameSparkleFieldNumber = 11,
    kIsBossFieldNumber = 14,
    kFacingDirYFieldNumber = 13,
    kBossTypeFieldNumber = 15,
  };
  // optional string stateAnimation = 3;
  bool has_stateanimation() const;
  private:
  bool _internal_has_stateanimation() const;
  public:
  void clear_stateanimation();
  const std::string& stateanimation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stateanimation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stateanimation();
  PROTOBUF_NODISCARD std::string* release_stateanimation();
  void set_allocated_stateanimation(std::string* stateanimation);
  private:
  const std::string& _internal_stateanimation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stateanimation(const std::string& value);
  std::string* _internal_mutable_stateanimation();
  public:

  // optional .Protocol.TransformData transform = 2;
  bool has_transform() const;
  private:
  bool _internal_has_transform() const;
  public:
  void clear_transform();
  const ::Protocol::TransformData& transform() const;
  PROTOBUF_NODISCARD ::Protocol::TransformData* release_transform();
  ::Protocol::TransformData* mutable_transform();
  void set_allocated_transform(::Protocol::TransformData* transform);
  private:
  const ::Protocol::TransformData& _internal_transform() const;
  ::Protocol::TransformData* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::Protocol::TransformData* transform);
  ::Protocol::TransformData* unsafe_arena_release_transform();

  // uint32 playerId = 1;
  void clear_playerid();
  uint32_t playerid() const;
  void set_playerid(uint32_t value);
  private:
  uint32_t _internal_playerid() const;
  void _internal_set_playerid(uint32_t value);
  public:

  // optional .Protocol.PlayerStateType stateType = 4;
  bool has_statetype() const;
  private:
  bool _internal_has_statetype() const;
  public:
  void clear_statetype();
  ::Protocol::PlayerStateType statetype() const;
  void set_statetype(::Protocol::PlayerStateType value);
  private:
  ::Protocol::PlayerStateType _internal_statetype() const;
  void _internal_set_statetype(::Protocol::PlayerStateType value);
  public:

  // optional bool isJailed = 5;
  bool has_isjailed() const;
  private:
  bool _internal_has_isjailed() const;
  public:
  void clear_isjailed();
  bool isjailed() const;
  void set_isjailed(bool value);
  private:
  bool _internal_isjailed() const;
  void _internal_set_isjailed(bool value);
  public:

  // optional bool flashlightOn = 6;
  bool has_flashlighton() const;
  private:
  bool _internal_has_flashlighton() const;
  public:
  void clear_flashlighton();
  bool flashlighton() const;
  void set_flashlighton(bool value);
  private:
  bool _internal_flashlighton() const;
  void _internal_set_flashlighton(bool value);
  public:

  // optional bool isLoading = 7;
  bool has_isloading() const;
  private:
  bool _internal_has_isloading() const;
  public:
  void clear_isloading();
  bool isloading() const;
  void set_isloading(bool value);
  private:
  bool _internal_isloading() const;
  void _internal_set_isloading(bool value);
  public:

  // optional bool miniGameSuccess = 8;
  bool has_minigamesuccess() const;
  private:
  bool _internal_has_minigamesuccess() const;
  public:
  void clear_minigamesuccess();
  bool minigamesuccess() const;
  void set_minigamesuccess(bool value);
  private:
  bool _internal_minigamesuccess() const;
  void _internal_set_minigamesuccess(bool value);
  public:

  // optional .Protocol.EscapeType escapeCode = 9;
  bool has_escapecode() const;
  private:
  bool _internal_has_escapecode() const;
  public:
  void clear_escapecode();
  ::Protocol::EscapeType escapecode() const;
  void set_escapecode(::Protocol::EscapeType value);
  private:
  ::Protocol::EscapeType _internal_escapecode() const;
  void _internal_set_escapecode(::Protocol::EscapeType value);
  public:

  // optional float alphaPlayer = 10;
  bool has_alphaplayer() const;
  private:
  bool _internal_has_alphaplayer() const;
  public:
  void clear_alphaplayer();
  float alphaplayer() const;
  void set_alphaplayer(float value);
  private:
  float _internal_alphaplayer() const;
  void _internal_set_alphaplayer(float value);
  public:

  // optional int32 facingDirX = 12;
  bool has_facingdirx() const;
  private:
  bool _internal_has_facingdirx() const;
  public:
  void clear_facingdirx();
  int32_t facingdirx() const;
  void set_facingdirx(int32_t value);
  private:
  int32_t _internal_facingdirx() const;
  void _internal_set_facingdirx(int32_t value);
  public:

  // optional bool miniGameSparkle = 11;
  bool has_minigamesparkle() const;
  private:
  bool _internal_has_minigamesparkle() const;
  public:
  void clear_minigamesparkle();
  bool minigamesparkle() const;
  void set_minigamesparkle(bool value);
  private:
  bool _internal_minigamesparkle() const;
  void _internal_set_minigamesparkle(bool value);
  public:

  // optional bool isBoss = 14;
  bool has_isboss() const;
  private:
  bool _internal_has_isboss() const;
  public:
  void clear_isboss();
  bool isboss() const;
  void set_isboss(bool value);
  private:
  bool _internal_isboss() const;
  void _internal_set_isboss(bool value);
  public:

  // optional int32 facingDirY = 13;
  bool has_facingdiry() const;
  private:
  bool _internal_has_facingdiry() const;
  public:
  void clear_facingdiry();
  int32_t facingdiry() const;
  void set_facingdiry(int32_t value);
  private:
  int32_t _internal_facingdiry() const;
  void _internal_set_facingdiry(int32_t value);
  public:

  // optional .Protocol.BossType bossType = 15;
  bool has_bosstype() const;
  private:
  bool _internal_has_bosstype() const;
  public:
  void clear_bosstype();
  ::Protocol::BossType bosstype() const;
  void set_bosstype(::Protocol::BossType value);
  private:
  ::Protocol::BossType _internal_bosstype() const;
  void _internal_set_bosstype(::Protocol::BossType value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.UpdatePlayerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stateanimation_;
    ::Protocol::TransformData* transform_;
    uint32_t playerid_;
    int statetype_;
    bool isjailed_;
    bool flashlighton_;
    bool isloading_;
    bool minigamesuccess_;
    int escapecode_;
    float alphaplayer_;
    int32_t facingdirx_;
    bool minigamesparkle_;
    bool isboss_;
    int32_t facingdiry_;
    int bosstype_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class UpdateGeneratorState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.UpdateGeneratorState) */ {
 public:
  inline UpdateGeneratorState() : UpdateGeneratorState(nullptr) {}
  ~UpdateGeneratorState() override;
  explicit PROTOBUF_CONSTEXPR UpdateGeneratorState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateGeneratorState(const UpdateGeneratorState& from);
  UpdateGeneratorState(UpdateGeneratorState&& from) noexcept
    : UpdateGeneratorState() {
    *this = ::std::move(from);
  }

  inline UpdateGeneratorState& operator=(const UpdateGeneratorState& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateGeneratorState& operator=(UpdateGeneratorState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateGeneratorState& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateGeneratorState* internal_default_instance() {
    return reinterpret_cast<const UpdateGeneratorState*>(
               &_UpdateGeneratorState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(UpdateGeneratorState& a, UpdateGeneratorState& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateGeneratorState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateGeneratorState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateGeneratorState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateGeneratorState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateGeneratorState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateGeneratorState& from) {
    UpdateGeneratorState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateGeneratorState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.UpdateGeneratorState";
  }
  protected:
  explicit UpdateGeneratorState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGeneratorIdFieldNumber = 1,
    kIsActivatedFieldNumber = 2,
    kIsSparklingFieldNumber = 3,
    kGeneratorsGageFieldNumber = 4,
  };
  // uint32 generatorId = 1;
  void clear_generatorid();
  uint32_t generatorid() const;
  void set_generatorid(uint32_t value);
  private:
  uint32_t _internal_generatorid() const;
  void _internal_set_generatorid(uint32_t value);
  public:

  // optional bool isActivated = 2;
  bool has_isactivated() const;
  private:
  bool _internal_has_isactivated() const;
  public:
  void clear_isactivated();
  bool isactivated() const;
  void set_isactivated(bool value);
  private:
  bool _internal_isactivated() const;
  void _internal_set_isactivated(bool value);
  public:

  // optional bool isSparkling = 3;
  bool has_issparkling() const;
  private:
  bool _internal_has_issparkling() const;
  public:
  void clear_issparkling();
  bool issparkling() const;
  void set_issparkling(bool value);
  private:
  bool _internal_issparkling() const;
  void _internal_set_issparkling(bool value);
  public:

  // optional uint32 generatorsGage = 4;
  bool has_generatorsgage() const;
  private:
  bool _internal_has_generatorsgage() const;
  public:
  void clear_generatorsgage();
  uint32_t generatorsgage() const;
  void set_generatorsgage(uint32_t value);
  private:
  uint32_t _internal_generatorsgage() const;
  void _internal_set_generatorsgage(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.UpdateGeneratorState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t generatorid_;
    bool isactivated_;
    bool issparkling_;
    uint32_t generatorsgage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class UpdateMiniGameState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.UpdateMiniGameState) */ {
 public:
  inline UpdateMiniGameState() : UpdateMiniGameState(nullptr) {}
  ~UpdateMiniGameState() override;
  explicit PROTOBUF_CONSTEXPR UpdateMiniGameState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateMiniGameState(const UpdateMiniGameState& from);
  UpdateMiniGameState(UpdateMiniGameState&& from) noexcept
    : UpdateMiniGameState() {
    *this = ::std::move(from);
  }

  inline UpdateMiniGameState& operator=(const UpdateMiniGameState& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateMiniGameState& operator=(UpdateMiniGameState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateMiniGameState& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateMiniGameState* internal_default_instance() {
    return reinterpret_cast<const UpdateMiniGameState*>(
               &_UpdateMiniGameState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UpdateMiniGameState& a, UpdateMiniGameState& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateMiniGameState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateMiniGameState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateMiniGameState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateMiniGameState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateMiniGameState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateMiniGameState& from) {
    UpdateMiniGameState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateMiniGameState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.UpdateMiniGameState";
  }
  protected:
  explicit UpdateMiniGameState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMiniGameIdFieldNumber = 1,
    kIsClearedFieldNumber = 2,
    kIsSparklingFieldNumber = 3,
  };
  // uint32 miniGameId = 1;
  void clear_minigameid();
  uint32_t minigameid() const;
  void set_minigameid(uint32_t value);
  private:
  uint32_t _internal_minigameid() const;
  void _internal_set_minigameid(uint32_t value);
  public:

  // optional bool isCleared = 2;
  bool has_iscleared() const;
  private:
  bool _internal_has_iscleared() const;
  public:
  void clear_iscleared();
  bool iscleared() const;
  void set_iscleared(bool value);
  private:
  bool _internal_iscleared() const;
  void _internal_set_iscleared(bool value);
  public:

  // optional bool isSparkling = 3;
  bool has_issparkling() const;
  private:
  bool _internal_has_issparkling() const;
  public:
  void clear_issparkling();
  bool issparkling() const;
  void set_issparkling(bool value);
  private:
  bool _internal_issparkling() const;
  void _internal_set_issparkling(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.UpdateMiniGameState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t minigameid_;
    bool iscleared_;
    bool issparkling_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class WorldStateDelta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.WorldStateDelta) */ {
 public:
  inline WorldStateDelta() : WorldStateDelta(nullptr) {}
  ~WorldStateDelta() override;
  explicit PROTOBUF_CONSTEXPR WorldStateDelta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorldStateDelta(const WorldStateDelta& from);
  WorldStateDelta(WorldStateDelta&& from) noexcept
    : WorldStateDelta() {
    *this = ::std::move(from);
  }

  inline WorldStateDelta& operator=(const WorldStateDelta& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldStateDelta& operator=(WorldStateDelta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorldStateDelta& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorldStateDelta* internal_default_instance() {
    return reinterpret_cast<const WorldStateDelta*>(
               &_WorldStateDelta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(WorldStateDelta& a, WorldStateDelta& b) {
    a.Swap(&b);
  }
  inline void Swap(WorldStateDelta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldStateDelta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorldStateDelta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorldStateDelta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorldStateDelta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorldStateDelta& from) {
    WorldStateDelta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorldStateDelta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.WorldStateDelta";
  }
  protected:
  explicit WorldStateDelta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerUpdatesFieldNumber = 1,
    kGeneratorUpdatesFieldNumber = 2,
    kMiniUpdatesFieldNumber = 3,
  };
  // repeated .Protocol.UpdatePlayerState playerUpdates = 1;
  int playerupdates_size() const;
  private:
  int _internal_playerupdates_size() const;
  public:
  void clear_playerupdates();
  ::Protocol::UpdatePlayerState* mutable_playerupdates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdatePlayerState >*
      mutable_playerupdates();
  private:
  const ::Protocol::UpdatePlayerState& _internal_playerupdates(int index) const;
  ::Protocol::UpdatePlayerState* _internal_add_playerupdates();
  public:
  const ::Protocol::UpdatePlayerState& playerupdates(int index) const;
  ::Protocol::UpdatePlayerState* add_playerupdates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdatePlayerState >&
      playerupdates() const;

  // repeated .Protocol.UpdateGeneratorState generatorUpdates = 2;
  int generatorupdates_size() const;
  private:
  int _internal_generatorupdates_size() const;
  public:
  void clear_generatorupdates();
  ::Protocol::UpdateGeneratorState* mutable_generatorupdates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdateGeneratorState >*
      mutable_generatorupdates();
  private:
  const ::Protocol::UpdateGeneratorState& _internal_generatorupdates(int index) const;
  ::Protocol::UpdateGeneratorState* _internal_add_generatorupdates();
  public:
  const ::Protocol::UpdateGeneratorState& generatorupdates(int index) const;
  ::Protocol::UpdateGeneratorState* add_generatorupdates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdateGeneratorState >&
      generatorupdates() const;

  // repeated .Protocol.UpdateMiniGameState miniUpdates = 3;
  int miniupdates_size() const;
  private:
  int _internal_miniupdates_size() const;
  public:
  void clear_miniupdates();
  ::Protocol::UpdateMiniGameState* mutable_miniupdates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdateMiniGameState >*
      mutable_miniupdates();
  private:
  const ::Protocol::UpdateMiniGameState& _internal_miniupdates(int index) const;
  ::Protocol::UpdateMiniGameState* _internal_add_miniupdates();
  public:
  const ::Protocol::UpdateMiniGameState& miniupdates(int index) const;
  ::Protocol::UpdateMiniGameState* add_miniupdates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdateMiniGameState >&
      miniupdates() const;

  // @@protoc_insertion_point(class_scope:Protocol.WorldStateDelta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdatePlayerState > playerupdates_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdateGeneratorState > generatorupdates_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdateMiniGameState > miniupdates_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class PlayerMoveRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PlayerMoveRequest) */ {
 public:
  inline PlayerMoveRequest() : PlayerMoveRequest(nullptr) {}
  ~PlayerMoveRequest() override;
  explicit PROTOBUF_CONSTEXPR PlayerMoveRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerMoveRequest(const PlayerMoveRequest& from);
  PlayerMoveRequest(PlayerMoveRequest&& from) noexcept
    : PlayerMoveRequest() {
    *this = ::std::move(from);
  }

  inline PlayerMoveRequest& operator=(const PlayerMoveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerMoveRequest& operator=(PlayerMoveRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerMoveRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerMoveRequest* internal_default_instance() {
    return reinterpret_cast<const PlayerMoveRequest*>(
               &_PlayerMoveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(PlayerMoveRequest& a, PlayerMoveRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerMoveRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerMoveRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerMoveRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerMoveRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerMoveRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayerMoveRequest& from) {
    PlayerMoveRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerMoveRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PlayerMoveRequest";
  }
  protected:
  explicit PlayerMoveRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewPositionFieldNumber = 2,
    kRotationFieldNumber = 3,
    kActorIdFieldNumber = 1,
  };
  // .Protocol.Vector3 newPosition = 2;
  bool has_newposition() const;
  private:
  bool _internal_has_newposition() const;
  public:
  void clear_newposition();
  const ::Protocol::Vector3& newposition() const;
  PROTOBUF_NODISCARD ::Protocol::Vector3* release_newposition();
  ::Protocol::Vector3* mutable_newposition();
  void set_allocated_newposition(::Protocol::Vector3* newposition);
  private:
  const ::Protocol::Vector3& _internal_newposition() const;
  ::Protocol::Vector3* _internal_mutable_newposition();
  public:
  void unsafe_arena_set_allocated_newposition(
      ::Protocol::Vector3* newposition);
  ::Protocol::Vector3* unsafe_arena_release_newposition();

  // .Protocol.Vector3 rotation = 3;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::Protocol::Vector3& rotation() const;
  PROTOBUF_NODISCARD ::Protocol::Vector3* release_rotation();
  ::Protocol::Vector3* mutable_rotation();
  void set_allocated_rotation(::Protocol::Vector3* rotation);
  private:
  const ::Protocol::Vector3& _internal_rotation() const;
  ::Protocol::Vector3* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::Protocol::Vector3* rotation);
  ::Protocol::Vector3* unsafe_arena_release_rotation();

  // uint32 actorId = 1;
  void clear_actorid();
  uint32_t actorid() const;
  void set_actorid(uint32_t value);
  private:
  uint32_t _internal_actorid() const;
  void _internal_set_actorid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PlayerMoveRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Protocol::Vector3* newposition_;
    ::Protocol::Vector3* rotation_;
    uint32_t actorid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class ChatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ChatRequest) */ {
 public:
  inline ChatRequest() : ChatRequest(nullptr) {}
  ~ChatRequest() override;
  explicit PROTOBUF_CONSTEXPR ChatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatRequest(const ChatRequest& from);
  ChatRequest(ChatRequest&& from) noexcept
    : ChatRequest() {
    *this = ::std::move(from);
  }

  inline ChatRequest& operator=(const ChatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatRequest& operator=(ChatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatRequest* internal_default_instance() {
    return reinterpret_cast<const ChatRequest*>(
               &_ChatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ChatRequest& a, ChatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatRequest& from) {
    ChatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ChatRequest";
  }
  protected:
  explicit ChatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSenderIdFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint32 sender_id = 1;
  void clear_sender_id();
  uint32_t sender_id() const;
  void set_sender_id(uint32_t value);
  private:
  uint32_t _internal_sender_id() const;
  void _internal_set_sender_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ChatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint32_t sender_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class ChatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.ChatResponse) */ {
 public:
  inline ChatResponse() : ChatResponse(nullptr) {}
  ~ChatResponse() override;
  explicit PROTOBUF_CONSTEXPR ChatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChatResponse(const ChatResponse& from);
  ChatResponse(ChatResponse&& from) noexcept
    : ChatResponse() {
    *this = ::std::move(from);
  }

  inline ChatResponse& operator=(const ChatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatResponse& operator=(ChatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatResponse* internal_default_instance() {
    return reinterpret_cast<const ChatResponse*>(
               &_ChatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ChatResponse& a, ChatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChatResponse& from) {
    ChatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.ChatResponse";
  }
  protected:
  explicit ChatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kSenderIdFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint32 sender_id = 1;
  void clear_sender_id();
  uint32_t sender_id() const;
  void set_sender_id(uint32_t value);
  private:
  uint32_t _internal_sender_id() const;
  void _internal_set_sender_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.ChatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint32_t sender_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoginRequest

// string userNickname = 1;
inline void LoginRequest::clear_usernickname() {
  _impl_.usernickname_.ClearToEmpty();
}
inline const std::string& LoginRequest::usernickname() const {
  // @@protoc_insertion_point(field_get:Protocol.LoginRequest.userNickname)
  return _internal_usernickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_usernickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.usernickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.LoginRequest.userNickname)
}
inline std::string* LoginRequest::mutable_usernickname() {
  std::string* _s = _internal_mutable_usernickname();
  // @@protoc_insertion_point(field_mutable:Protocol.LoginRequest.userNickname)
  return _s;
}
inline const std::string& LoginRequest::_internal_usernickname() const {
  return _impl_.usernickname_.Get();
}
inline void LoginRequest::_internal_set_usernickname(const std::string& value) {
  
  _impl_.usernickname_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_usernickname() {
  
  return _impl_.usernickname_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_usernickname() {
  // @@protoc_insertion_point(field_release:Protocol.LoginRequest.userNickname)
  return _impl_.usernickname_.Release();
}
inline void LoginRequest::set_allocated_usernickname(std::string* usernickname) {
  if (usernickname != nullptr) {
    
  } else {
    
  }
  _impl_.usernickname_.SetAllocated(usernickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.usernickname_.IsDefault()) {
    _impl_.usernickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.LoginRequest.userNickname)
}

// -------------------------------------------------------------------

// LoginResponse

// bool success = 1;
inline void LoginResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool LoginResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool LoginResponse::success() const {
  // @@protoc_insertion_point(field_get:Protocol.LoginResponse.success)
  return _internal_success();
}
inline void LoginResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void LoginResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.LoginResponse.success)
}

// string error_message = 2;
inline void LoginResponse::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& LoginResponse::error_message() const {
  // @@protoc_insertion_point(field_get:Protocol.LoginResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.LoginResponse.error_message)
}
inline std::string* LoginResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:Protocol.LoginResponse.error_message)
  return _s;
}
inline const std::string& LoginResponse::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void LoginResponse::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:Protocol.LoginResponse.error_message)
  return _impl_.error_message_.Release();
}
inline void LoginResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.LoginResponse.error_message)
}

// uint32 playerID = 3;
inline void LoginResponse::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t LoginResponse::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t LoginResponse::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.LoginResponse.playerID)
  return _internal_playerid();
}
inline void LoginResponse::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void LoginResponse::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.LoginResponse.playerID)
}

// string userNickname = 4;
inline void LoginResponse::clear_usernickname() {
  _impl_.usernickname_.ClearToEmpty();
}
inline const std::string& LoginResponse::usernickname() const {
  // @@protoc_insertion_point(field_get:Protocol.LoginResponse.userNickname)
  return _internal_usernickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_usernickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.usernickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.LoginResponse.userNickname)
}
inline std::string* LoginResponse::mutable_usernickname() {
  std::string* _s = _internal_mutable_usernickname();
  // @@protoc_insertion_point(field_mutable:Protocol.LoginResponse.userNickname)
  return _s;
}
inline const std::string& LoginResponse::_internal_usernickname() const {
  return _impl_.usernickname_.Get();
}
inline void LoginResponse::_internal_set_usernickname(const std::string& value) {
  
  _impl_.usernickname_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_usernickname() {
  
  return _impl_.usernickname_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_usernickname() {
  // @@protoc_insertion_point(field_release:Protocol.LoginResponse.userNickname)
  return _impl_.usernickname_.Release();
}
inline void LoginResponse::set_allocated_usernickname(std::string* usernickname) {
  if (usernickname != nullptr) {
    
  } else {
    
  }
  _impl_.usernickname_.SetAllocated(usernickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.usernickname_.IsDefault()) {
    _impl_.usernickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.LoginResponse.userNickname)
}

// -------------------------------------------------------------------

// CreateRoomRequest

// -------------------------------------------------------------------

// CreateRoomResponse

// bool success = 1;
inline void CreateRoomResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool CreateRoomResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool CreateRoomResponse::success() const {
  // @@protoc_insertion_point(field_get:Protocol.CreateRoomResponse.success)
  return _internal_success();
}
inline void CreateRoomResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void CreateRoomResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.CreateRoomResponse.success)
}

// string error = 2;
inline void CreateRoomResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& CreateRoomResponse::error() const {
  // @@protoc_insertion_point(field_get:Protocol.CreateRoomResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoomResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.CreateRoomResponse.error)
}
inline std::string* CreateRoomResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:Protocol.CreateRoomResponse.error)
  return _s;
}
inline const std::string& CreateRoomResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void CreateRoomResponse::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoomResponse::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoomResponse::release_error() {
  // @@protoc_insertion_point(field_release:Protocol.CreateRoomResponse.error)
  return _impl_.error_.Release();
}
inline void CreateRoomResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.CreateRoomResponse.error)
}

// uint32 roomId = 3;
inline void CreateRoomResponse::clear_roomid() {
  _impl_.roomid_ = 0u;
}
inline uint32_t CreateRoomResponse::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint32_t CreateRoomResponse::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.CreateRoomResponse.roomId)
  return _internal_roomid();
}
inline void CreateRoomResponse::_internal_set_roomid(uint32_t value) {
  
  _impl_.roomid_ = value;
}
inline void CreateRoomResponse::set_roomid(uint32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.CreateRoomResponse.roomId)
}

// -------------------------------------------------------------------

// ListRoomsRequest

// -------------------------------------------------------------------

// ListRoomsResponse

// repeated .Protocol.RoomInfo rooms = 1;
inline int ListRoomsResponse::_internal_rooms_size() const {
  return _impl_.rooms_.size();
}
inline int ListRoomsResponse::rooms_size() const {
  return _internal_rooms_size();
}
inline void ListRoomsResponse::clear_rooms() {
  _impl_.rooms_.Clear();
}
inline ::Protocol::RoomInfo* ListRoomsResponse::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.ListRoomsResponse.rooms)
  return _impl_.rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >*
ListRoomsResponse::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.ListRoomsResponse.rooms)
  return &_impl_.rooms_;
}
inline const ::Protocol::RoomInfo& ListRoomsResponse::_internal_rooms(int index) const {
  return _impl_.rooms_.Get(index);
}
inline const ::Protocol::RoomInfo& ListRoomsResponse::rooms(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.ListRoomsResponse.rooms)
  return _internal_rooms(index);
}
inline ::Protocol::RoomInfo* ListRoomsResponse::_internal_add_rooms() {
  return _impl_.rooms_.Add();
}
inline ::Protocol::RoomInfo* ListRoomsResponse::add_rooms() {
  ::Protocol::RoomInfo* _add = _internal_add_rooms();
  // @@protoc_insertion_point(field_add:Protocol.ListRoomsResponse.rooms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::RoomInfo >&
ListRoomsResponse::rooms() const {
  // @@protoc_insertion_point(field_list:Protocol.ListRoomsResponse.rooms)
  return _impl_.rooms_;
}

// -------------------------------------------------------------------

// JoinRoomRequest

// uint32 playerId = 1;
inline void JoinRoomRequest::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t JoinRoomRequest::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t JoinRoomRequest::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.JoinRoomRequest.playerId)
  return _internal_playerid();
}
inline void JoinRoomRequest::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void JoinRoomRequest::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.JoinRoomRequest.playerId)
}

// uint32 roomId = 2;
inline void JoinRoomRequest::clear_roomid() {
  _impl_.roomid_ = 0u;
}
inline uint32_t JoinRoomRequest::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint32_t JoinRoomRequest::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.JoinRoomRequest.roomId)
  return _internal_roomid();
}
inline void JoinRoomRequest::_internal_set_roomid(uint32_t value) {
  
  _impl_.roomid_ = value;
}
inline void JoinRoomRequest::set_roomid(uint32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.JoinRoomRequest.roomId)
}

// -------------------------------------------------------------------

// JoinRoomResponse

// bool success = 1;
inline void JoinRoomResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool JoinRoomResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool JoinRoomResponse::success() const {
  // @@protoc_insertion_point(field_get:Protocol.JoinRoomResponse.success)
  return _internal_success();
}
inline void JoinRoomResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void JoinRoomResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Protocol.JoinRoomResponse.success)
}

// string error = 2;
inline void JoinRoomResponse::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& JoinRoomResponse::error() const {
  // @@protoc_insertion_point(field_get:Protocol.JoinRoomResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinRoomResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.JoinRoomResponse.error)
}
inline std::string* JoinRoomResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:Protocol.JoinRoomResponse.error)
  return _s;
}
inline const std::string& JoinRoomResponse::_internal_error() const {
  return _impl_.error_.Get();
}
inline void JoinRoomResponse::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinRoomResponse::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinRoomResponse::release_error() {
  // @@protoc_insertion_point(field_release:Protocol.JoinRoomResponse.error)
  return _impl_.error_.Release();
}
inline void JoinRoomResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.JoinRoomResponse.error)
}

// .Protocol.RoomInfo room = 3;
inline bool JoinRoomResponse::_internal_has_room() const {
  return this != internal_default_instance() && _impl_.room_ != nullptr;
}
inline bool JoinRoomResponse::has_room() const {
  return _internal_has_room();
}
inline void JoinRoomResponse::clear_room() {
  if (GetArenaForAllocation() == nullptr && _impl_.room_ != nullptr) {
    delete _impl_.room_;
  }
  _impl_.room_ = nullptr;
}
inline const ::Protocol::RoomInfo& JoinRoomResponse::_internal_room() const {
  const ::Protocol::RoomInfo* p = _impl_.room_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::RoomInfo&>(
      ::Protocol::_RoomInfo_default_instance_);
}
inline const ::Protocol::RoomInfo& JoinRoomResponse::room() const {
  // @@protoc_insertion_point(field_get:Protocol.JoinRoomResponse.room)
  return _internal_room();
}
inline void JoinRoomResponse::unsafe_arena_set_allocated_room(
    ::Protocol::RoomInfo* room) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.room_);
  }
  _impl_.room_ = room;
  if (room) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.JoinRoomResponse.room)
}
inline ::Protocol::RoomInfo* JoinRoomResponse::release_room() {
  
  ::Protocol::RoomInfo* temp = _impl_.room_;
  _impl_.room_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::RoomInfo* JoinRoomResponse::unsafe_arena_release_room() {
  // @@protoc_insertion_point(field_release:Protocol.JoinRoomResponse.room)
  
  ::Protocol::RoomInfo* temp = _impl_.room_;
  _impl_.room_ = nullptr;
  return temp;
}
inline ::Protocol::RoomInfo* JoinRoomResponse::_internal_mutable_room() {
  
  if (_impl_.room_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::RoomInfo>(GetArenaForAllocation());
    _impl_.room_ = p;
  }
  return _impl_.room_;
}
inline ::Protocol::RoomInfo* JoinRoomResponse::mutable_room() {
  ::Protocol::RoomInfo* _msg = _internal_mutable_room();
  // @@protoc_insertion_point(field_mutable:Protocol.JoinRoomResponse.room)
  return _msg;
}
inline void JoinRoomResponse::set_allocated_room(::Protocol::RoomInfo* room) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.room_;
  }
  if (room) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(room);
    if (message_arena != submessage_arena) {
      room = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.room_ = room;
  // @@protoc_insertion_point(field_set_allocated:Protocol.JoinRoomResponse.room)
}

// -------------------------------------------------------------------

// RoomInfo

// uint32 roomId = 1;
inline void RoomInfo::clear_roomid() {
  _impl_.roomid_ = 0u;
}
inline uint32_t RoomInfo::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint32_t RoomInfo::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.RoomInfo.roomId)
  return _internal_roomid();
}
inline void RoomInfo::_internal_set_roomid(uint32_t value) {
  
  _impl_.roomid_ = value;
}
inline void RoomInfo::set_roomid(uint32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.RoomInfo.roomId)
}

// uint32 creatorId = 2;
inline void RoomInfo::clear_creatorid() {
  _impl_.creatorid_ = 0u;
}
inline uint32_t RoomInfo::_internal_creatorid() const {
  return _impl_.creatorid_;
}
inline uint32_t RoomInfo::creatorid() const {
  // @@protoc_insertion_point(field_get:Protocol.RoomInfo.creatorId)
  return _internal_creatorid();
}
inline void RoomInfo::_internal_set_creatorid(uint32_t value) {
  
  _impl_.creatorid_ = value;
}
inline void RoomInfo::set_creatorid(uint32_t value) {
  _internal_set_creatorid(value);
  // @@protoc_insertion_point(field_set:Protocol.RoomInfo.creatorId)
}

// string creatorName = 3;
inline void RoomInfo::clear_creatorname() {
  _impl_.creatorname_.ClearToEmpty();
}
inline const std::string& RoomInfo::creatorname() const {
  // @@protoc_insertion_point(field_get:Protocol.RoomInfo.creatorName)
  return _internal_creatorname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomInfo::set_creatorname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.creatorname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.RoomInfo.creatorName)
}
inline std::string* RoomInfo::mutable_creatorname() {
  std::string* _s = _internal_mutable_creatorname();
  // @@protoc_insertion_point(field_mutable:Protocol.RoomInfo.creatorName)
  return _s;
}
inline const std::string& RoomInfo::_internal_creatorname() const {
  return _impl_.creatorname_.Get();
}
inline void RoomInfo::_internal_set_creatorname(const std::string& value) {
  
  _impl_.creatorname_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomInfo::_internal_mutable_creatorname() {
  
  return _impl_.creatorname_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomInfo::release_creatorname() {
  // @@protoc_insertion_point(field_release:Protocol.RoomInfo.creatorName)
  return _impl_.creatorname_.Release();
}
inline void RoomInfo::set_allocated_creatorname(std::string* creatorname) {
  if (creatorname != nullptr) {
    
  } else {
    
  }
  _impl_.creatorname_.SetAllocated(creatorname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creatorname_.IsDefault()) {
    _impl_.creatorname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.RoomInfo.creatorName)
}

// uint32 currentCount = 4;
inline void RoomInfo::clear_currentcount() {
  _impl_.currentcount_ = 0u;
}
inline uint32_t RoomInfo::_internal_currentcount() const {
  return _impl_.currentcount_;
}
inline uint32_t RoomInfo::currentcount() const {
  // @@protoc_insertion_point(field_get:Protocol.RoomInfo.currentCount)
  return _internal_currentcount();
}
inline void RoomInfo::_internal_set_currentcount(uint32_t value) {
  
  _impl_.currentcount_ = value;
}
inline void RoomInfo::set_currentcount(uint32_t value) {
  _internal_set_currentcount(value);
  // @@protoc_insertion_point(field_set:Protocol.RoomInfo.currentCount)
}

// uint32 maxCount = 5;
inline void RoomInfo::clear_maxcount() {
  _impl_.maxcount_ = 0u;
}
inline uint32_t RoomInfo::_internal_maxcount() const {
  return _impl_.maxcount_;
}
inline uint32_t RoomInfo::maxcount() const {
  // @@protoc_insertion_point(field_get:Protocol.RoomInfo.maxCount)
  return _internal_maxcount();
}
inline void RoomInfo::_internal_set_maxcount(uint32_t value) {
  
  _impl_.maxcount_ = value;
}
inline void RoomInfo::set_maxcount(uint32_t value) {
  _internal_set_maxcount(value);
  // @@protoc_insertion_point(field_set:Protocol.RoomInfo.maxCount)
}

// repeated .Protocol.PlayerInfo players = 6;
inline int RoomInfo::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int RoomInfo::players_size() const {
  return _internal_players_size();
}
inline void RoomInfo::clear_players() {
  _impl_.players_.Clear();
}
inline ::Protocol::PlayerInfo* RoomInfo::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.RoomInfo.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
RoomInfo::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.RoomInfo.players)
  return &_impl_.players_;
}
inline const ::Protocol::PlayerInfo& RoomInfo::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::PlayerInfo& RoomInfo::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.RoomInfo.players)
  return _internal_players(index);
}
inline ::Protocol::PlayerInfo* RoomInfo::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::PlayerInfo* RoomInfo::add_players() {
  ::Protocol::PlayerInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.RoomInfo.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
RoomInfo::players() const {
  // @@protoc_insertion_point(field_list:Protocol.RoomInfo.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// PlayerInfo

// uint32 playerId = 1;
inline void PlayerInfo::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t PlayerInfo::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t PlayerInfo::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.playerId)
  return _internal_playerid();
}
inline void PlayerInfo::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void PlayerInfo::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerInfo.playerId)
}

// string nickname = 2;
inline void PlayerInfo::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& PlayerInfo::nickname() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerInfo.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.PlayerInfo.nickname)
}
inline std::string* PlayerInfo::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerInfo.nickname)
  return _s;
}
inline const std::string& PlayerInfo::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void PlayerInfo::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_nickname() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerInfo.nickname)
  return _impl_.nickname_.Release();
}
inline void PlayerInfo::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerInfo.nickname)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PlayersUpdate

// map<uint32, .Protocol.PlayerInfo> players = 1;
inline int PlayersUpdate::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int PlayersUpdate::players_size() const {
  return _internal_players_size();
}
inline void PlayersUpdate::clear_players() {
  _impl_.players_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::Protocol::PlayerInfo >&
PlayersUpdate::_internal_players() const {
  return _impl_.players_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::Protocol::PlayerInfo >&
PlayersUpdate::players() const {
  // @@protoc_insertion_point(field_map:Protocol.PlayersUpdate.players)
  return _internal_players();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::Protocol::PlayerInfo >*
PlayersUpdate::_internal_mutable_players() {
  return _impl_.players_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::Protocol::PlayerInfo >*
PlayersUpdate::mutable_players() {
  // @@protoc_insertion_point(field_mutable_map:Protocol.PlayersUpdate.players)
  return _internal_mutable_players();
}

// -------------------------------------------------------------------

// PlayerReadyRequest

// bool isReady = 2;
inline void PlayerReadyRequest::clear_isready() {
  _impl_.isready_ = false;
}
inline bool PlayerReadyRequest::_internal_isready() const {
  return _impl_.isready_;
}
inline bool PlayerReadyRequest::isready() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerReadyRequest.isReady)
  return _internal_isready();
}
inline void PlayerReadyRequest::_internal_set_isready(bool value) {
  
  _impl_.isready_ = value;
}
inline void PlayerReadyRequest::set_isready(bool value) {
  _internal_set_isready(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerReadyRequest.isReady)
}

// -------------------------------------------------------------------

// ReadyInfo

// uint32 playerId = 1;
inline void ReadyInfo::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t ReadyInfo::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t ReadyInfo::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.ReadyInfo.playerId)
  return _internal_playerid();
}
inline void ReadyInfo::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void ReadyInfo::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.ReadyInfo.playerId)
}

// bool isReady = 2;
inline void ReadyInfo::clear_isready() {
  _impl_.isready_ = false;
}
inline bool ReadyInfo::_internal_isready() const {
  return _impl_.isready_;
}
inline bool ReadyInfo::isready() const {
  // @@protoc_insertion_point(field_get:Protocol.ReadyInfo.isReady)
  return _internal_isready();
}
inline void ReadyInfo::_internal_set_isready(bool value) {
  
  _impl_.isready_ = value;
}
inline void ReadyInfo::set_isready(bool value) {
  _internal_set_isready(value);
  // @@protoc_insertion_point(field_set:Protocol.ReadyInfo.isReady)
}

// -------------------------------------------------------------------

// PlayerReadyResponse

// uint32 roomId = 1;
inline void PlayerReadyResponse::clear_roomid() {
  _impl_.roomid_ = 0u;
}
inline uint32_t PlayerReadyResponse::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint32_t PlayerReadyResponse::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerReadyResponse.roomId)
  return _internal_roomid();
}
inline void PlayerReadyResponse::_internal_set_roomid(uint32_t value) {
  
  _impl_.roomid_ = value;
}
inline void PlayerReadyResponse::set_roomid(uint32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerReadyResponse.roomId)
}

// repeated .Protocol.ReadyInfo players = 4;
inline int PlayerReadyResponse::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int PlayerReadyResponse::players_size() const {
  return _internal_players_size();
}
inline void PlayerReadyResponse::clear_players() {
  _impl_.players_.Clear();
}
inline ::Protocol::ReadyInfo* PlayerReadyResponse::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerReadyResponse.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ReadyInfo >*
PlayerReadyResponse::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.PlayerReadyResponse.players)
  return &_impl_.players_;
}
inline const ::Protocol::ReadyInfo& PlayerReadyResponse::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::ReadyInfo& PlayerReadyResponse::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerReadyResponse.players)
  return _internal_players(index);
}
inline ::Protocol::ReadyInfo* PlayerReadyResponse::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::ReadyInfo* PlayerReadyResponse::add_players() {
  ::Protocol::ReadyInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.PlayerReadyResponse.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::ReadyInfo >&
PlayerReadyResponse::players() const {
  // @@protoc_insertion_point(field_list:Protocol.PlayerReadyResponse.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// GameStartNotification

// uint32 roomId = 1;
inline void GameStartNotification::clear_roomid() {
  _impl_.roomid_ = 0u;
}
inline uint32_t GameStartNotification::_internal_roomid() const {
  return _impl_.roomid_;
}
inline uint32_t GameStartNotification::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.GameStartNotification.roomId)
  return _internal_roomid();
}
inline void GameStartNotification::_internal_set_roomid(uint32_t value) {
  
  _impl_.roomid_ = value;
}
inline void GameStartNotification::set_roomid(uint32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.GameStartNotification.roomId)
}

// repeated .Protocol.PlayerInfo players = 2;
inline int GameStartNotification::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int GameStartNotification::players_size() const {
  return _internal_players_size();
}
inline void GameStartNotification::clear_players() {
  _impl_.players_.Clear();
}
inline ::Protocol::PlayerInfo* GameStartNotification::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.GameStartNotification.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >*
GameStartNotification::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.GameStartNotification.players)
  return &_impl_.players_;
}
inline const ::Protocol::PlayerInfo& GameStartNotification::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::PlayerInfo& GameStartNotification::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.GameStartNotification.players)
  return _internal_players(index);
}
inline ::Protocol::PlayerInfo* GameStartNotification::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::PlayerInfo* GameStartNotification::add_players() {
  ::Protocol::PlayerInfo* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.GameStartNotification.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerInfo >&
GameStartNotification::players() const {
  // @@protoc_insertion_point(field_list:Protocol.GameStartNotification.players)
  return _impl_.players_;
}

// repeated .Protocol.Role playerRoles = 3;
inline int GameStartNotification::_internal_playerroles_size() const {
  return _impl_.playerroles_.size();
}
inline int GameStartNotification::playerroles_size() const {
  return _internal_playerroles_size();
}
inline void GameStartNotification::clear_playerroles() {
  _impl_.playerroles_.Clear();
}
inline ::Protocol::Role GameStartNotification::_internal_playerroles(int index) const {
  return static_cast< ::Protocol::Role >(_impl_.playerroles_.Get(index));
}
inline ::Protocol::Role GameStartNotification::playerroles(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.GameStartNotification.playerRoles)
  return _internal_playerroles(index);
}
inline void GameStartNotification::set_playerroles(int index, ::Protocol::Role value) {
  _impl_.playerroles_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.GameStartNotification.playerRoles)
}
inline void GameStartNotification::_internal_add_playerroles(::Protocol::Role value) {
  _impl_.playerroles_.Add(value);
}
inline void GameStartNotification::add_playerroles(::Protocol::Role value) {
  _internal_add_playerroles(value);
  // @@protoc_insertion_point(field_add:Protocol.GameStartNotification.playerRoles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
GameStartNotification::playerroles() const {
  // @@protoc_insertion_point(field_list:Protocol.GameStartNotification.playerRoles)
  return _impl_.playerroles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
GameStartNotification::_internal_mutable_playerroles() {
  return &_impl_.playerroles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
GameStartNotification::mutable_playerroles() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.GameStartNotification.playerRoles)
  return _internal_mutable_playerroles();
}

// .Protocol.BossType boss_type = 4;
inline void GameStartNotification::clear_boss_type() {
  _impl_.boss_type_ = 0;
}
inline ::Protocol::BossType GameStartNotification::_internal_boss_type() const {
  return static_cast< ::Protocol::BossType >(_impl_.boss_type_);
}
inline ::Protocol::BossType GameStartNotification::boss_type() const {
  // @@protoc_insertion_point(field_get:Protocol.GameStartNotification.boss_type)
  return _internal_boss_type();
}
inline void GameStartNotification::_internal_set_boss_type(::Protocol::BossType value) {
  
  _impl_.boss_type_ = value;
}
inline void GameStartNotification::set_boss_type(::Protocol::BossType value) {
  _internal_set_boss_type(value);
  // @@protoc_insertion_point(field_set:Protocol.GameStartNotification.boss_type)
}

// -------------------------------------------------------------------

// PlayerRole

// uint32 playerId = 1;
inline void PlayerRole::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t PlayerRole::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t PlayerRole::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerRole.playerId)
  return _internal_playerid();
}
inline void PlayerRole::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void PlayerRole::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerRole.playerId)
}

// .Protocol.ActorRole role = 2;
inline void PlayerRole::clear_role() {
  _impl_.role_ = 0;
}
inline ::Protocol::ActorRole PlayerRole::_internal_role() const {
  return static_cast< ::Protocol::ActorRole >(_impl_.role_);
}
inline ::Protocol::ActorRole PlayerRole::role() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerRole.role)
  return _internal_role();
}
inline void PlayerRole::_internal_set_role(::Protocol::ActorRole value) {
  
  _impl_.role_ = value;
}
inline void PlayerRole::set_role(::Protocol::ActorRole value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerRole.role)
}

// -------------------------------------------------------------------

// PlayerFullStateRequest

// uint32 playerId = 1;
inline void PlayerFullStateRequest::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t PlayerFullStateRequest::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t PlayerFullStateRequest::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.playerId)
  return _internal_playerid();
}
inline void PlayerFullStateRequest::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void PlayerFullStateRequest::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.playerId)
}

// repeated bool life = 2;
inline int PlayerFullStateRequest::_internal_life_size() const {
  return _impl_.life_.size();
}
inline int PlayerFullStateRequest::life_size() const {
  return _internal_life_size();
}
inline void PlayerFullStateRequest::clear_life() {
  _impl_.life_.Clear();
}
inline bool PlayerFullStateRequest::_internal_life(int index) const {
  return _impl_.life_.Get(index);
}
inline bool PlayerFullStateRequest::life(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.life)
  return _internal_life(index);
}
inline void PlayerFullStateRequest::set_life(int index, bool value) {
  _impl_.life_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.life)
}
inline void PlayerFullStateRequest::_internal_add_life(bool value) {
  _impl_.life_.Add(value);
}
inline void PlayerFullStateRequest::add_life(bool value) {
  _internal_add_life(value);
  // @@protoc_insertion_point(field_add:Protocol.PlayerFullStateRequest.life)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
PlayerFullStateRequest::_internal_life() const {
  return _impl_.life_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
PlayerFullStateRequest::life() const {
  // @@protoc_insertion_point(field_list:Protocol.PlayerFullStateRequest.life)
  return _internal_life();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
PlayerFullStateRequest::_internal_mutable_life() {
  return &_impl_.life_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
PlayerFullStateRequest::mutable_life() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.PlayerFullStateRequest.life)
  return _internal_mutable_life();
}

// repeated bool deathPlayer = 3;
inline int PlayerFullStateRequest::_internal_deathplayer_size() const {
  return _impl_.deathplayer_.size();
}
inline int PlayerFullStateRequest::deathplayer_size() const {
  return _internal_deathplayer_size();
}
inline void PlayerFullStateRequest::clear_deathplayer() {
  _impl_.deathplayer_.Clear();
}
inline bool PlayerFullStateRequest::_internal_deathplayer(int index) const {
  return _impl_.deathplayer_.Get(index);
}
inline bool PlayerFullStateRequest::deathplayer(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.deathPlayer)
  return _internal_deathplayer(index);
}
inline void PlayerFullStateRequest::set_deathplayer(int index, bool value) {
  _impl_.deathplayer_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.deathPlayer)
}
inline void PlayerFullStateRequest::_internal_add_deathplayer(bool value) {
  _impl_.deathplayer_.Add(value);
}
inline void PlayerFullStateRequest::add_deathplayer(bool value) {
  _internal_add_deathplayer(value);
  // @@protoc_insertion_point(field_add:Protocol.PlayerFullStateRequest.deathPlayer)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
PlayerFullStateRequest::_internal_deathplayer() const {
  return _impl_.deathplayer_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
PlayerFullStateRequest::deathplayer() const {
  // @@protoc_insertion_point(field_list:Protocol.PlayerFullStateRequest.deathPlayer)
  return _internal_deathplayer();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
PlayerFullStateRequest::_internal_mutable_deathplayer() {
  return &_impl_.deathplayer_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
PlayerFullStateRequest::mutable_deathplayer() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.PlayerFullStateRequest.deathPlayer)
  return _internal_mutable_deathplayer();
}

// string nickname = 4;
inline void PlayerFullStateRequest::clear_nickname() {
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& PlayerFullStateRequest::nickname() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerFullStateRequest::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.nickname)
}
inline std::string* PlayerFullStateRequest::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerFullStateRequest.nickname)
  return _s;
}
inline const std::string& PlayerFullStateRequest::_internal_nickname() const {
  return _impl_.nickname_.Get();
}
inline void PlayerFullStateRequest::_internal_set_nickname(const std::string& value) {
  
  _impl_.nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerFullStateRequest::_internal_mutable_nickname() {
  
  return _impl_.nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerFullStateRequest::release_nickname() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerFullStateRequest.nickname)
  return _impl_.nickname_.Release();
}
inline void PlayerFullStateRequest::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  _impl_.nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.nickname_.IsDefault()) {
    _impl_.nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerFullStateRequest.nickname)
}

// .Protocol.Vector3 position = 5;
inline bool PlayerFullStateRequest::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool PlayerFullStateRequest::has_position() const {
  return _internal_has_position();
}
inline const ::Protocol::Vector3& PlayerFullStateRequest::_internal_position() const {
  const ::Protocol::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector3&>(
      ::Protocol::_Vector3_default_instance_);
}
inline const ::Protocol::Vector3& PlayerFullStateRequest::position() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.position)
  return _internal_position();
}
inline void PlayerFullStateRequest::unsafe_arena_set_allocated_position(
    ::Protocol::Vector3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerFullStateRequest.position)
}
inline ::Protocol::Vector3* PlayerFullStateRequest::release_position() {
  
  ::Protocol::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Vector3* PlayerFullStateRequest::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerFullStateRequest.position)
  
  ::Protocol::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::Protocol::Vector3* PlayerFullStateRequest::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector3>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::Protocol::Vector3* PlayerFullStateRequest::mutable_position() {
  ::Protocol::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerFullStateRequest.position)
  return _msg;
}
inline void PlayerFullStateRequest::set_allocated_position(::Protocol::Vector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerFullStateRequest.position)
}

// .Protocol.Vector3 scale = 6;
inline bool PlayerFullStateRequest::_internal_has_scale() const {
  return this != internal_default_instance() && _impl_.scale_ != nullptr;
}
inline bool PlayerFullStateRequest::has_scale() const {
  return _internal_has_scale();
}
inline const ::Protocol::Vector3& PlayerFullStateRequest::_internal_scale() const {
  const ::Protocol::Vector3* p = _impl_.scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector3&>(
      ::Protocol::_Vector3_default_instance_);
}
inline const ::Protocol::Vector3& PlayerFullStateRequest::scale() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.scale)
  return _internal_scale();
}
inline void PlayerFullStateRequest::unsafe_arena_set_allocated_scale(
    ::Protocol::Vector3* scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scale_);
  }
  _impl_.scale_ = scale;
  if (scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerFullStateRequest.scale)
}
inline ::Protocol::Vector3* PlayerFullStateRequest::release_scale() {
  
  ::Protocol::Vector3* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Vector3* PlayerFullStateRequest::unsafe_arena_release_scale() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerFullStateRequest.scale)
  
  ::Protocol::Vector3* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
  return temp;
}
inline ::Protocol::Vector3* PlayerFullStateRequest::_internal_mutable_scale() {
  
  if (_impl_.scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector3>(GetArenaForAllocation());
    _impl_.scale_ = p;
  }
  return _impl_.scale_;
}
inline ::Protocol::Vector3* PlayerFullStateRequest::mutable_scale() {
  ::Protocol::Vector3* _msg = _internal_mutable_scale();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerFullStateRequest.scale)
  return _msg;
}
inline void PlayerFullStateRequest::set_allocated_scale(::Protocol::Vector3* scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scale_);
  }
  if (scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scale));
    if (message_arena != submessage_arena) {
      scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.scale_ = scale;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerFullStateRequest.scale)
}

// int32 facingDirX = 9;
inline void PlayerFullStateRequest::clear_facingdirx() {
  _impl_.facingdirx_ = 0;
}
inline int32_t PlayerFullStateRequest::_internal_facingdirx() const {
  return _impl_.facingdirx_;
}
inline int32_t PlayerFullStateRequest::facingdirx() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.facingDirX)
  return _internal_facingdirx();
}
inline void PlayerFullStateRequest::_internal_set_facingdirx(int32_t value) {
  
  _impl_.facingdirx_ = value;
}
inline void PlayerFullStateRequest::set_facingdirx(int32_t value) {
  _internal_set_facingdirx(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.facingDirX)
}

// int32 facingDirY = 10;
inline void PlayerFullStateRequest::clear_facingdiry() {
  _impl_.facingdiry_ = 0;
}
inline int32_t PlayerFullStateRequest::_internal_facingdiry() const {
  return _impl_.facingdiry_;
}
inline int32_t PlayerFullStateRequest::facingdiry() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.facingDirY)
  return _internal_facingdiry();
}
inline void PlayerFullStateRequest::_internal_set_facingdiry(int32_t value) {
  
  _impl_.facingdiry_ = value;
}
inline void PlayerFullStateRequest::set_facingdiry(int32_t value) {
  _internal_set_facingdiry(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.facingDirY)
}

// bool isJailed = 11;
inline void PlayerFullStateRequest::clear_isjailed() {
  _impl_.isjailed_ = false;
}
inline bool PlayerFullStateRequest::_internal_isjailed() const {
  return _impl_.isjailed_;
}
inline bool PlayerFullStateRequest::isjailed() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.isJailed)
  return _internal_isjailed();
}
inline void PlayerFullStateRequest::_internal_set_isjailed(bool value) {
  
  _impl_.isjailed_ = value;
}
inline void PlayerFullStateRequest::set_isjailed(bool value) {
  _internal_set_isjailed(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.isJailed)
}

// .Protocol.PlayerStateType stateType = 12;
inline void PlayerFullStateRequest::clear_statetype() {
  _impl_.statetype_ = 0;
}
inline ::Protocol::PlayerStateType PlayerFullStateRequest::_internal_statetype() const {
  return static_cast< ::Protocol::PlayerStateType >(_impl_.statetype_);
}
inline ::Protocol::PlayerStateType PlayerFullStateRequest::statetype() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.stateType)
  return _internal_statetype();
}
inline void PlayerFullStateRequest::_internal_set_statetype(::Protocol::PlayerStateType value) {
  
  _impl_.statetype_ = value;
}
inline void PlayerFullStateRequest::set_statetype(::Protocol::PlayerStateType value) {
  _internal_set_statetype(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.stateType)
}

// bool successGenerator = 13;
inline void PlayerFullStateRequest::clear_successgenerator() {
  _impl_.successgenerator_ = false;
}
inline bool PlayerFullStateRequest::_internal_successgenerator() const {
  return _impl_.successgenerator_;
}
inline bool PlayerFullStateRequest::successgenerator() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.successGenerator)
  return _internal_successgenerator();
}
inline void PlayerFullStateRequest::_internal_set_successgenerator(bool value) {
  
  _impl_.successgenerator_ = value;
}
inline void PlayerFullStateRequest::set_successgenerator(bool value) {
  _internal_set_successgenerator(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.successGenerator)
}

// bool miniGameSuccess = 14;
inline void PlayerFullStateRequest::clear_minigamesuccess() {
  _impl_.minigamesuccess_ = false;
}
inline bool PlayerFullStateRequest::_internal_minigamesuccess() const {
  return _impl_.minigamesuccess_;
}
inline bool PlayerFullStateRequest::minigamesuccess() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.miniGameSuccess)
  return _internal_minigamesuccess();
}
inline void PlayerFullStateRequest::_internal_set_minigamesuccess(bool value) {
  
  _impl_.minigamesuccess_ = value;
}
inline void PlayerFullStateRequest::set_minigamesuccess(bool value) {
  _internal_set_minigamesuccess(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.miniGameSuccess)
}

// string escapeMessage = 15;
inline void PlayerFullStateRequest::clear_escapemessage() {
  _impl_.escapemessage_.ClearToEmpty();
}
inline const std::string& PlayerFullStateRequest::escapemessage() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.escapeMessage)
  return _internal_escapemessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerFullStateRequest::set_escapemessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.escapemessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.escapeMessage)
}
inline std::string* PlayerFullStateRequest::mutable_escapemessage() {
  std::string* _s = _internal_mutable_escapemessage();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerFullStateRequest.escapeMessage)
  return _s;
}
inline const std::string& PlayerFullStateRequest::_internal_escapemessage() const {
  return _impl_.escapemessage_.Get();
}
inline void PlayerFullStateRequest::_internal_set_escapemessage(const std::string& value) {
  
  _impl_.escapemessage_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerFullStateRequest::_internal_mutable_escapemessage() {
  
  return _impl_.escapemessage_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerFullStateRequest::release_escapemessage() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerFullStateRequest.escapeMessage)
  return _impl_.escapemessage_.Release();
}
inline void PlayerFullStateRequest::set_allocated_escapemessage(std::string* escapemessage) {
  if (escapemessage != nullptr) {
    
  } else {
    
  }
  _impl_.escapemessage_.SetAllocated(escapemessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.escapemessage_.IsDefault()) {
    _impl_.escapemessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerFullStateRequest.escapeMessage)
}

// float alphaPlayer = 16;
inline void PlayerFullStateRequest::clear_alphaplayer() {
  _impl_.alphaplayer_ = 0;
}
inline float PlayerFullStateRequest::_internal_alphaplayer() const {
  return _impl_.alphaplayer_;
}
inline float PlayerFullStateRequest::alphaplayer() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.alphaPlayer)
  return _internal_alphaplayer();
}
inline void PlayerFullStateRequest::_internal_set_alphaplayer(float value) {
  
  _impl_.alphaplayer_ = value;
}
inline void PlayerFullStateRequest::set_alphaplayer(float value) {
  _internal_set_alphaplayer(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.alphaPlayer)
}

// bool miniGameSparkle = 17;
inline void PlayerFullStateRequest::clear_minigamesparkle() {
  _impl_.minigamesparkle_ = false;
}
inline bool PlayerFullStateRequest::_internal_minigamesparkle() const {
  return _impl_.minigamesparkle_;
}
inline bool PlayerFullStateRequest::minigamesparkle() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.miniGameSparkle)
  return _internal_minigamesparkle();
}
inline void PlayerFullStateRequest::_internal_set_minigamesparkle(bool value) {
  
  _impl_.minigamesparkle_ = value;
}
inline void PlayerFullStateRequest::set_minigamesparkle(bool value) {
  _internal_set_minigamesparkle(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.miniGameSparkle)
}

// .Protocol.EscapeType escapeCode = 18;
inline void PlayerFullStateRequest::clear_escapecode() {
  _impl_.escapecode_ = 0;
}
inline ::Protocol::EscapeType PlayerFullStateRequest::_internal_escapecode() const {
  return static_cast< ::Protocol::EscapeType >(_impl_.escapecode_);
}
inline ::Protocol::EscapeType PlayerFullStateRequest::escapecode() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.escapeCode)
  return _internal_escapecode();
}
inline void PlayerFullStateRequest::_internal_set_escapecode(::Protocol::EscapeType value) {
  
  _impl_.escapecode_ = value;
}
inline void PlayerFullStateRequest::set_escapecode(::Protocol::EscapeType value) {
  _internal_set_escapecode(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.escapeCode)
}

// bool hasUpgradedFlashlight = 19;
inline void PlayerFullStateRequest::clear_hasupgradedflashlight() {
  _impl_.hasupgradedflashlight_ = false;
}
inline bool PlayerFullStateRequest::_internal_hasupgradedflashlight() const {
  return _impl_.hasupgradedflashlight_;
}
inline bool PlayerFullStateRequest::hasupgradedflashlight() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.hasUpgradedFlashlight)
  return _internal_hasupgradedflashlight();
}
inline void PlayerFullStateRequest::_internal_set_hasupgradedflashlight(bool value) {
  
  _impl_.hasupgradedflashlight_ = value;
}
inline void PlayerFullStateRequest::set_hasupgradedflashlight(bool value) {
  _internal_set_hasupgradedflashlight(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.hasUpgradedFlashlight)
}

// bool isLoading = 20;
inline void PlayerFullStateRequest::clear_isloading() {
  _impl_.isloading_ = false;
}
inline bool PlayerFullStateRequest::_internal_isloading() const {
  return _impl_.isloading_;
}
inline bool PlayerFullStateRequest::isloading() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.isLoading)
  return _internal_isloading();
}
inline void PlayerFullStateRequest::_internal_set_isloading(bool value) {
  
  _impl_.isloading_ = value;
}
inline void PlayerFullStateRequest::set_isloading(bool value) {
  _internal_set_isloading(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.isLoading)
}

// uint32 characterChoice = 21;
inline void PlayerFullStateRequest::clear_characterchoice() {
  _impl_.characterchoice_ = 0u;
}
inline uint32_t PlayerFullStateRequest::_internal_characterchoice() const {
  return _impl_.characterchoice_;
}
inline uint32_t PlayerFullStateRequest::characterchoice() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.characterChoice)
  return _internal_characterchoice();
}
inline void PlayerFullStateRequest::_internal_set_characterchoice(uint32_t value) {
  
  _impl_.characterchoice_ = value;
}
inline void PlayerFullStateRequest::set_characterchoice(uint32_t value) {
  _internal_set_characterchoice(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.characterChoice)
}

// bool isBoss = 22;
inline void PlayerFullStateRequest::clear_isboss() {
  _impl_.isboss_ = false;
}
inline bool PlayerFullStateRequest::_internal_isboss() const {
  return _impl_.isboss_;
}
inline bool PlayerFullStateRequest::isboss() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.isBoss)
  return _internal_isboss();
}
inline void PlayerFullStateRequest::_internal_set_isboss(bool value) {
  
  _impl_.isboss_ = value;
}
inline void PlayerFullStateRequest::set_isboss(bool value) {
  _internal_set_isboss(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.isBoss)
}

// .Protocol.BossType bossType = 23;
inline void PlayerFullStateRequest::clear_bosstype() {
  _impl_.bosstype_ = 0;
}
inline ::Protocol::BossType PlayerFullStateRequest::_internal_bosstype() const {
  return static_cast< ::Protocol::BossType >(_impl_.bosstype_);
}
inline ::Protocol::BossType PlayerFullStateRequest::bosstype() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerFullStateRequest.bossType)
  return _internal_bosstype();
}
inline void PlayerFullStateRequest::_internal_set_bosstype(::Protocol::BossType value) {
  
  _impl_.bosstype_ = value;
}
inline void PlayerFullStateRequest::set_bosstype(::Protocol::BossType value) {
  _internal_set_bosstype(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerFullStateRequest.bossType)
}

// -------------------------------------------------------------------

// InitGeneratorStateRequest

// uint32 generatorId = 1;
inline void InitGeneratorStateRequest::clear_generatorid() {
  _impl_.generatorid_ = 0u;
}
inline uint32_t InitGeneratorStateRequest::_internal_generatorid() const {
  return _impl_.generatorid_;
}
inline uint32_t InitGeneratorStateRequest::generatorid() const {
  // @@protoc_insertion_point(field_get:Protocol.InitGeneratorStateRequest.generatorId)
  return _internal_generatorid();
}
inline void InitGeneratorStateRequest::_internal_set_generatorid(uint32_t value) {
  
  _impl_.generatorid_ = value;
}
inline void InitGeneratorStateRequest::set_generatorid(uint32_t value) {
  _internal_set_generatorid(value);
  // @@protoc_insertion_point(field_set:Protocol.InitGeneratorStateRequest.generatorId)
}

// .Protocol.TransformData transform = 2;
inline bool InitGeneratorStateRequest::_internal_has_transform() const {
  return this != internal_default_instance() && _impl_.transform_ != nullptr;
}
inline bool InitGeneratorStateRequest::has_transform() const {
  return _internal_has_transform();
}
inline const ::Protocol::TransformData& InitGeneratorStateRequest::_internal_transform() const {
  const ::Protocol::TransformData* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::TransformData&>(
      ::Protocol::_TransformData_default_instance_);
}
inline const ::Protocol::TransformData& InitGeneratorStateRequest::transform() const {
  // @@protoc_insertion_point(field_get:Protocol.InitGeneratorStateRequest.transform)
  return _internal_transform();
}
inline void InitGeneratorStateRequest::unsafe_arena_set_allocated_transform(
    ::Protocol::TransformData* transform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.InitGeneratorStateRequest.transform)
}
inline ::Protocol::TransformData* InitGeneratorStateRequest::release_transform() {
  
  ::Protocol::TransformData* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::TransformData* InitGeneratorStateRequest::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:Protocol.InitGeneratorStateRequest.transform)
  
  ::Protocol::TransformData* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::Protocol::TransformData* InitGeneratorStateRequest::_internal_mutable_transform() {
  
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::TransformData>(GetArenaForAllocation());
    _impl_.transform_ = p;
  }
  return _impl_.transform_;
}
inline ::Protocol::TransformData* InitGeneratorStateRequest::mutable_transform() {
  ::Protocol::TransformData* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:Protocol.InitGeneratorStateRequest.transform)
  return _msg;
}
inline void InitGeneratorStateRequest::set_allocated_transform(::Protocol::TransformData* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transform_);
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transform));
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:Protocol.InitGeneratorStateRequest.transform)
}

// bool isActivated = 3;
inline void InitGeneratorStateRequest::clear_isactivated() {
  _impl_.isactivated_ = false;
}
inline bool InitGeneratorStateRequest::_internal_isactivated() const {
  return _impl_.isactivated_;
}
inline bool InitGeneratorStateRequest::isactivated() const {
  // @@protoc_insertion_point(field_get:Protocol.InitGeneratorStateRequest.isActivated)
  return _internal_isactivated();
}
inline void InitGeneratorStateRequest::_internal_set_isactivated(bool value) {
  
  _impl_.isactivated_ = value;
}
inline void InitGeneratorStateRequest::set_isactivated(bool value) {
  _internal_set_isactivated(value);
  // @@protoc_insertion_point(field_set:Protocol.InitGeneratorStateRequest.isActivated)
}

// bool isSparkling = 4;
inline void InitGeneratorStateRequest::clear_issparkling() {
  _impl_.issparkling_ = false;
}
inline bool InitGeneratorStateRequest::_internal_issparkling() const {
  return _impl_.issparkling_;
}
inline bool InitGeneratorStateRequest::issparkling() const {
  // @@protoc_insertion_point(field_get:Protocol.InitGeneratorStateRequest.isSparkling)
  return _internal_issparkling();
}
inline void InitGeneratorStateRequest::_internal_set_issparkling(bool value) {
  
  _impl_.issparkling_ = value;
}
inline void InitGeneratorStateRequest::set_issparkling(bool value) {
  _internal_set_issparkling(value);
  // @@protoc_insertion_point(field_set:Protocol.InitGeneratorStateRequest.isSparkling)
}

// bool isDone = 5;
inline void InitGeneratorStateRequest::clear_isdone() {
  _impl_.isdone_ = false;
}
inline bool InitGeneratorStateRequest::_internal_isdone() const {
  return _impl_.isdone_;
}
inline bool InitGeneratorStateRequest::isdone() const {
  // @@protoc_insertion_point(field_get:Protocol.InitGeneratorStateRequest.isDone)
  return _internal_isdone();
}
inline void InitGeneratorStateRequest::_internal_set_isdone(bool value) {
  
  _impl_.isdone_ = value;
}
inline void InitGeneratorStateRequest::set_isdone(bool value) {
  _internal_set_isdone(value);
  // @@protoc_insertion_point(field_set:Protocol.InitGeneratorStateRequest.isDone)
}

// uint32 generatorsGage = 6;
inline void InitGeneratorStateRequest::clear_generatorsgage() {
  _impl_.generatorsgage_ = 0u;
}
inline uint32_t InitGeneratorStateRequest::_internal_generatorsgage() const {
  return _impl_.generatorsgage_;
}
inline uint32_t InitGeneratorStateRequest::generatorsgage() const {
  // @@protoc_insertion_point(field_get:Protocol.InitGeneratorStateRequest.generatorsGage)
  return _internal_generatorsgage();
}
inline void InitGeneratorStateRequest::_internal_set_generatorsgage(uint32_t value) {
  
  _impl_.generatorsgage_ = value;
}
inline void InitGeneratorStateRequest::set_generatorsgage(uint32_t value) {
  _internal_set_generatorsgage(value);
  // @@protoc_insertion_point(field_set:Protocol.InitGeneratorStateRequest.generatorsGage)
}

// -------------------------------------------------------------------

// InitMiniGameStateRequest

// uint32 miniGameId = 1;
inline void InitMiniGameStateRequest::clear_minigameid() {
  _impl_.minigameid_ = 0u;
}
inline uint32_t InitMiniGameStateRequest::_internal_minigameid() const {
  return _impl_.minigameid_;
}
inline uint32_t InitMiniGameStateRequest::minigameid() const {
  // @@protoc_insertion_point(field_get:Protocol.InitMiniGameStateRequest.miniGameId)
  return _internal_minigameid();
}
inline void InitMiniGameStateRequest::_internal_set_minigameid(uint32_t value) {
  
  _impl_.minigameid_ = value;
}
inline void InitMiniGameStateRequest::set_minigameid(uint32_t value) {
  _internal_set_minigameid(value);
  // @@protoc_insertion_point(field_set:Protocol.InitMiniGameStateRequest.miniGameId)
}

// .Protocol.TransformData transform = 2;
inline bool InitMiniGameStateRequest::_internal_has_transform() const {
  return this != internal_default_instance() && _impl_.transform_ != nullptr;
}
inline bool InitMiniGameStateRequest::has_transform() const {
  return _internal_has_transform();
}
inline const ::Protocol::TransformData& InitMiniGameStateRequest::_internal_transform() const {
  const ::Protocol::TransformData* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::TransformData&>(
      ::Protocol::_TransformData_default_instance_);
}
inline const ::Protocol::TransformData& InitMiniGameStateRequest::transform() const {
  // @@protoc_insertion_point(field_get:Protocol.InitMiniGameStateRequest.transform)
  return _internal_transform();
}
inline void InitMiniGameStateRequest::unsafe_arena_set_allocated_transform(
    ::Protocol::TransformData* transform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.InitMiniGameStateRequest.transform)
}
inline ::Protocol::TransformData* InitMiniGameStateRequest::release_transform() {
  
  ::Protocol::TransformData* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::TransformData* InitMiniGameStateRequest::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:Protocol.InitMiniGameStateRequest.transform)
  
  ::Protocol::TransformData* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::Protocol::TransformData* InitMiniGameStateRequest::_internal_mutable_transform() {
  
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::TransformData>(GetArenaForAllocation());
    _impl_.transform_ = p;
  }
  return _impl_.transform_;
}
inline ::Protocol::TransformData* InitMiniGameStateRequest::mutable_transform() {
  ::Protocol::TransformData* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:Protocol.InitMiniGameStateRequest.transform)
  return _msg;
}
inline void InitMiniGameStateRequest::set_allocated_transform(::Protocol::TransformData* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transform_);
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transform));
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:Protocol.InitMiniGameStateRequest.transform)
}

// bool isCleared = 3;
inline void InitMiniGameStateRequest::clear_iscleared() {
  _impl_.iscleared_ = false;
}
inline bool InitMiniGameStateRequest::_internal_iscleared() const {
  return _impl_.iscleared_;
}
inline bool InitMiniGameStateRequest::iscleared() const {
  // @@protoc_insertion_point(field_get:Protocol.InitMiniGameStateRequest.isCleared)
  return _internal_iscleared();
}
inline void InitMiniGameStateRequest::_internal_set_iscleared(bool value) {
  
  _impl_.iscleared_ = value;
}
inline void InitMiniGameStateRequest::set_iscleared(bool value) {
  _internal_set_iscleared(value);
  // @@protoc_insertion_point(field_set:Protocol.InitMiniGameStateRequest.isCleared)
}

// bool isSparkling = 4;
inline void InitMiniGameStateRequest::clear_issparkling() {
  _impl_.issparkling_ = false;
}
inline bool InitMiniGameStateRequest::_internal_issparkling() const {
  return _impl_.issparkling_;
}
inline bool InitMiniGameStateRequest::issparkling() const {
  // @@protoc_insertion_point(field_get:Protocol.InitMiniGameStateRequest.isSparkling)
  return _internal_issparkling();
}
inline void InitMiniGameStateRequest::_internal_set_issparkling(bool value) {
  
  _impl_.issparkling_ = value;
}
inline void InitMiniGameStateRequest::set_issparkling(bool value) {
  _internal_set_issparkling(value);
  // @@protoc_insertion_point(field_set:Protocol.InitMiniGameStateRequest.isSparkling)
}

// -------------------------------------------------------------------

// InitWorldStateRequest

// repeated .Protocol.PlayerFullStateRequest players = 1;
inline int InitWorldStateRequest::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int InitWorldStateRequest::players_size() const {
  return _internal_players_size();
}
inline void InitWorldStateRequest::clear_players() {
  _impl_.players_.Clear();
}
inline ::Protocol::PlayerFullStateRequest* InitWorldStateRequest::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.InitWorldStateRequest.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerFullStateRequest >*
InitWorldStateRequest::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.InitWorldStateRequest.players)
  return &_impl_.players_;
}
inline const ::Protocol::PlayerFullStateRequest& InitWorldStateRequest::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::PlayerFullStateRequest& InitWorldStateRequest::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.InitWorldStateRequest.players)
  return _internal_players(index);
}
inline ::Protocol::PlayerFullStateRequest* InitWorldStateRequest::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::PlayerFullStateRequest* InitWorldStateRequest::add_players() {
  ::Protocol::PlayerFullStateRequest* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.InitWorldStateRequest.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PlayerFullStateRequest >&
InitWorldStateRequest::players() const {
  // @@protoc_insertion_point(field_list:Protocol.InitWorldStateRequest.players)
  return _impl_.players_;
}

// repeated .Protocol.InitGeneratorStateRequest generators = 2;
inline int InitWorldStateRequest::_internal_generators_size() const {
  return _impl_.generators_.size();
}
inline int InitWorldStateRequest::generators_size() const {
  return _internal_generators_size();
}
inline void InitWorldStateRequest::clear_generators() {
  _impl_.generators_.Clear();
}
inline ::Protocol::InitGeneratorStateRequest* InitWorldStateRequest::mutable_generators(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.InitWorldStateRequest.generators)
  return _impl_.generators_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::InitGeneratorStateRequest >*
InitWorldStateRequest::mutable_generators() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.InitWorldStateRequest.generators)
  return &_impl_.generators_;
}
inline const ::Protocol::InitGeneratorStateRequest& InitWorldStateRequest::_internal_generators(int index) const {
  return _impl_.generators_.Get(index);
}
inline const ::Protocol::InitGeneratorStateRequest& InitWorldStateRequest::generators(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.InitWorldStateRequest.generators)
  return _internal_generators(index);
}
inline ::Protocol::InitGeneratorStateRequest* InitWorldStateRequest::_internal_add_generators() {
  return _impl_.generators_.Add();
}
inline ::Protocol::InitGeneratorStateRequest* InitWorldStateRequest::add_generators() {
  ::Protocol::InitGeneratorStateRequest* _add = _internal_add_generators();
  // @@protoc_insertion_point(field_add:Protocol.InitWorldStateRequest.generators)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::InitGeneratorStateRequest >&
InitWorldStateRequest::generators() const {
  // @@protoc_insertion_point(field_list:Protocol.InitWorldStateRequest.generators)
  return _impl_.generators_;
}

// repeated .Protocol.InitMiniGameStateRequest miniGames = 3;
inline int InitWorldStateRequest::_internal_minigames_size() const {
  return _impl_.minigames_.size();
}
inline int InitWorldStateRequest::minigames_size() const {
  return _internal_minigames_size();
}
inline void InitWorldStateRequest::clear_minigames() {
  _impl_.minigames_.Clear();
}
inline ::Protocol::InitMiniGameStateRequest* InitWorldStateRequest::mutable_minigames(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.InitWorldStateRequest.miniGames)
  return _impl_.minigames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::InitMiniGameStateRequest >*
InitWorldStateRequest::mutable_minigames() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.InitWorldStateRequest.miniGames)
  return &_impl_.minigames_;
}
inline const ::Protocol::InitMiniGameStateRequest& InitWorldStateRequest::_internal_minigames(int index) const {
  return _impl_.minigames_.Get(index);
}
inline const ::Protocol::InitMiniGameStateRequest& InitWorldStateRequest::minigames(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.InitWorldStateRequest.miniGames)
  return _internal_minigames(index);
}
inline ::Protocol::InitMiniGameStateRequest* InitWorldStateRequest::_internal_add_minigames() {
  return _impl_.minigames_.Add();
}
inline ::Protocol::InitMiniGameStateRequest* InitWorldStateRequest::add_minigames() {
  ::Protocol::InitMiniGameStateRequest* _add = _internal_add_minigames();
  // @@protoc_insertion_point(field_add:Protocol.InitWorldStateRequest.miniGames)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::InitMiniGameStateRequest >&
InitWorldStateRequest::minigames() const {
  // @@protoc_insertion_point(field_list:Protocol.InitWorldStateRequest.miniGames)
  return _impl_.minigames_;
}

// -------------------------------------------------------------------

// UpdatePlayerState

// uint32 playerId = 1;
inline void UpdatePlayerState::clear_playerid() {
  _impl_.playerid_ = 0u;
}
inline uint32_t UpdatePlayerState::_internal_playerid() const {
  return _impl_.playerid_;
}
inline uint32_t UpdatePlayerState::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.playerId)
  return _internal_playerid();
}
inline void UpdatePlayerState::_internal_set_playerid(uint32_t value) {
  
  _impl_.playerid_ = value;
}
inline void UpdatePlayerState::set_playerid(uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdatePlayerState.playerId)
}

// optional .Protocol.TransformData transform = 2;
inline bool UpdatePlayerState::_internal_has_transform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.transform_ != nullptr);
  return value;
}
inline bool UpdatePlayerState::has_transform() const {
  return _internal_has_transform();
}
inline const ::Protocol::TransformData& UpdatePlayerState::_internal_transform() const {
  const ::Protocol::TransformData* p = _impl_.transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::TransformData&>(
      ::Protocol::_TransformData_default_instance_);
}
inline const ::Protocol::TransformData& UpdatePlayerState::transform() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.transform)
  return _internal_transform();
}
inline void UpdatePlayerState::unsafe_arena_set_allocated_transform(
    ::Protocol::TransformData* transform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transform_);
  }
  _impl_.transform_ = transform;
  if (transform) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.UpdatePlayerState.transform)
}
inline ::Protocol::TransformData* UpdatePlayerState::release_transform() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Protocol::TransformData* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::TransformData* UpdatePlayerState::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:Protocol.UpdatePlayerState.transform)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::Protocol::TransformData* temp = _impl_.transform_;
  _impl_.transform_ = nullptr;
  return temp;
}
inline ::Protocol::TransformData* UpdatePlayerState::_internal_mutable_transform() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::TransformData>(GetArenaForAllocation());
    _impl_.transform_ = p;
  }
  return _impl_.transform_;
}
inline ::Protocol::TransformData* UpdatePlayerState::mutable_transform() {
  ::Protocol::TransformData* _msg = _internal_mutable_transform();
  // @@protoc_insertion_point(field_mutable:Protocol.UpdatePlayerState.transform)
  return _msg;
}
inline void UpdatePlayerState::set_allocated_transform(::Protocol::TransformData* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.transform_);
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transform));
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:Protocol.UpdatePlayerState.transform)
}

// optional string stateAnimation = 3;
inline bool UpdatePlayerState::_internal_has_stateanimation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdatePlayerState::has_stateanimation() const {
  return _internal_has_stateanimation();
}
inline void UpdatePlayerState::clear_stateanimation() {
  _impl_.stateanimation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdatePlayerState::stateanimation() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.stateAnimation)
  return _internal_stateanimation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdatePlayerState::set_stateanimation(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.stateanimation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.UpdatePlayerState.stateAnimation)
}
inline std::string* UpdatePlayerState::mutable_stateanimation() {
  std::string* _s = _internal_mutable_stateanimation();
  // @@protoc_insertion_point(field_mutable:Protocol.UpdatePlayerState.stateAnimation)
  return _s;
}
inline const std::string& UpdatePlayerState::_internal_stateanimation() const {
  return _impl_.stateanimation_.Get();
}
inline void UpdatePlayerState::_internal_set_stateanimation(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stateanimation_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdatePlayerState::_internal_mutable_stateanimation() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stateanimation_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdatePlayerState::release_stateanimation() {
  // @@protoc_insertion_point(field_release:Protocol.UpdatePlayerState.stateAnimation)
  if (!_internal_has_stateanimation()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.stateanimation_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stateanimation_.IsDefault()) {
    _impl_.stateanimation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void UpdatePlayerState::set_allocated_stateanimation(std::string* stateanimation) {
  if (stateanimation != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stateanimation_.SetAllocated(stateanimation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stateanimation_.IsDefault()) {
    _impl_.stateanimation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.UpdatePlayerState.stateAnimation)
}

// optional .Protocol.PlayerStateType stateType = 4;
inline bool UpdatePlayerState::_internal_has_statetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdatePlayerState::has_statetype() const {
  return _internal_has_statetype();
}
inline void UpdatePlayerState::clear_statetype() {
  _impl_.statetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::Protocol::PlayerStateType UpdatePlayerState::_internal_statetype() const {
  return static_cast< ::Protocol::PlayerStateType >(_impl_.statetype_);
}
inline ::Protocol::PlayerStateType UpdatePlayerState::statetype() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.stateType)
  return _internal_statetype();
}
inline void UpdatePlayerState::_internal_set_statetype(::Protocol::PlayerStateType value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.statetype_ = value;
}
inline void UpdatePlayerState::set_statetype(::Protocol::PlayerStateType value) {
  _internal_set_statetype(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdatePlayerState.stateType)
}

// optional bool isJailed = 5;
inline bool UpdatePlayerState::_internal_has_isjailed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UpdatePlayerState::has_isjailed() const {
  return _internal_has_isjailed();
}
inline void UpdatePlayerState::clear_isjailed() {
  _impl_.isjailed_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool UpdatePlayerState::_internal_isjailed() const {
  return _impl_.isjailed_;
}
inline bool UpdatePlayerState::isjailed() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.isJailed)
  return _internal_isjailed();
}
inline void UpdatePlayerState::_internal_set_isjailed(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.isjailed_ = value;
}
inline void UpdatePlayerState::set_isjailed(bool value) {
  _internal_set_isjailed(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdatePlayerState.isJailed)
}

// optional bool flashlightOn = 6;
inline bool UpdatePlayerState::_internal_has_flashlighton() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UpdatePlayerState::has_flashlighton() const {
  return _internal_has_flashlighton();
}
inline void UpdatePlayerState::clear_flashlighton() {
  _impl_.flashlighton_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool UpdatePlayerState::_internal_flashlighton() const {
  return _impl_.flashlighton_;
}
inline bool UpdatePlayerState::flashlighton() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.flashlightOn)
  return _internal_flashlighton();
}
inline void UpdatePlayerState::_internal_set_flashlighton(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.flashlighton_ = value;
}
inline void UpdatePlayerState::set_flashlighton(bool value) {
  _internal_set_flashlighton(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdatePlayerState.flashlightOn)
}

// optional bool isLoading = 7;
inline bool UpdatePlayerState::_internal_has_isloading() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UpdatePlayerState::has_isloading() const {
  return _internal_has_isloading();
}
inline void UpdatePlayerState::clear_isloading() {
  _impl_.isloading_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool UpdatePlayerState::_internal_isloading() const {
  return _impl_.isloading_;
}
inline bool UpdatePlayerState::isloading() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.isLoading)
  return _internal_isloading();
}
inline void UpdatePlayerState::_internal_set_isloading(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.isloading_ = value;
}
inline void UpdatePlayerState::set_isloading(bool value) {
  _internal_set_isloading(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdatePlayerState.isLoading)
}

// optional bool miniGameSuccess = 8;
inline bool UpdatePlayerState::_internal_has_minigamesuccess() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool UpdatePlayerState::has_minigamesuccess() const {
  return _internal_has_minigamesuccess();
}
inline void UpdatePlayerState::clear_minigamesuccess() {
  _impl_.minigamesuccess_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool UpdatePlayerState::_internal_minigamesuccess() const {
  return _impl_.minigamesuccess_;
}
inline bool UpdatePlayerState::minigamesuccess() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.miniGameSuccess)
  return _internal_minigamesuccess();
}
inline void UpdatePlayerState::_internal_set_minigamesuccess(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.minigamesuccess_ = value;
}
inline void UpdatePlayerState::set_minigamesuccess(bool value) {
  _internal_set_minigamesuccess(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdatePlayerState.miniGameSuccess)
}

// optional .Protocol.EscapeType escapeCode = 9;
inline bool UpdatePlayerState::_internal_has_escapecode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UpdatePlayerState::has_escapecode() const {
  return _internal_has_escapecode();
}
inline void UpdatePlayerState::clear_escapecode() {
  _impl_.escapecode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::Protocol::EscapeType UpdatePlayerState::_internal_escapecode() const {
  return static_cast< ::Protocol::EscapeType >(_impl_.escapecode_);
}
inline ::Protocol::EscapeType UpdatePlayerState::escapecode() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.escapeCode)
  return _internal_escapecode();
}
inline void UpdatePlayerState::_internal_set_escapecode(::Protocol::EscapeType value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.escapecode_ = value;
}
inline void UpdatePlayerState::set_escapecode(::Protocol::EscapeType value) {
  _internal_set_escapecode(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdatePlayerState.escapeCode)
}

// optional float alphaPlayer = 10;
inline bool UpdatePlayerState::_internal_has_alphaplayer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool UpdatePlayerState::has_alphaplayer() const {
  return _internal_has_alphaplayer();
}
inline void UpdatePlayerState::clear_alphaplayer() {
  _impl_.alphaplayer_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float UpdatePlayerState::_internal_alphaplayer() const {
  return _impl_.alphaplayer_;
}
inline float UpdatePlayerState::alphaplayer() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.alphaPlayer)
  return _internal_alphaplayer();
}
inline void UpdatePlayerState::_internal_set_alphaplayer(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.alphaplayer_ = value;
}
inline void UpdatePlayerState::set_alphaplayer(float value) {
  _internal_set_alphaplayer(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdatePlayerState.alphaPlayer)
}

// optional bool miniGameSparkle = 11;
inline bool UpdatePlayerState::_internal_has_minigamesparkle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool UpdatePlayerState::has_minigamesparkle() const {
  return _internal_has_minigamesparkle();
}
inline void UpdatePlayerState::clear_minigamesparkle() {
  _impl_.minigamesparkle_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool UpdatePlayerState::_internal_minigamesparkle() const {
  return _impl_.minigamesparkle_;
}
inline bool UpdatePlayerState::minigamesparkle() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.miniGameSparkle)
  return _internal_minigamesparkle();
}
inline void UpdatePlayerState::_internal_set_minigamesparkle(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.minigamesparkle_ = value;
}
inline void UpdatePlayerState::set_minigamesparkle(bool value) {
  _internal_set_minigamesparkle(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdatePlayerState.miniGameSparkle)
}

// optional int32 facingDirX = 12;
inline bool UpdatePlayerState::_internal_has_facingdirx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool UpdatePlayerState::has_facingdirx() const {
  return _internal_has_facingdirx();
}
inline void UpdatePlayerState::clear_facingdirx() {
  _impl_.facingdirx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t UpdatePlayerState::_internal_facingdirx() const {
  return _impl_.facingdirx_;
}
inline int32_t UpdatePlayerState::facingdirx() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.facingDirX)
  return _internal_facingdirx();
}
inline void UpdatePlayerState::_internal_set_facingdirx(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.facingdirx_ = value;
}
inline void UpdatePlayerState::set_facingdirx(int32_t value) {
  _internal_set_facingdirx(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdatePlayerState.facingDirX)
}

// optional int32 facingDirY = 13;
inline bool UpdatePlayerState::_internal_has_facingdiry() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool UpdatePlayerState::has_facingdiry() const {
  return _internal_has_facingdiry();
}
inline void UpdatePlayerState::clear_facingdiry() {
  _impl_.facingdiry_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int32_t UpdatePlayerState::_internal_facingdiry() const {
  return _impl_.facingdiry_;
}
inline int32_t UpdatePlayerState::facingdiry() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.facingDirY)
  return _internal_facingdiry();
}
inline void UpdatePlayerState::_internal_set_facingdiry(int32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.facingdiry_ = value;
}
inline void UpdatePlayerState::set_facingdiry(int32_t value) {
  _internal_set_facingdiry(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdatePlayerState.facingDirY)
}

// optional bool isBoss = 14;
inline bool UpdatePlayerState::_internal_has_isboss() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool UpdatePlayerState::has_isboss() const {
  return _internal_has_isboss();
}
inline void UpdatePlayerState::clear_isboss() {
  _impl_.isboss_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool UpdatePlayerState::_internal_isboss() const {
  return _impl_.isboss_;
}
inline bool UpdatePlayerState::isboss() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.isBoss)
  return _internal_isboss();
}
inline void UpdatePlayerState::_internal_set_isboss(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.isboss_ = value;
}
inline void UpdatePlayerState::set_isboss(bool value) {
  _internal_set_isboss(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdatePlayerState.isBoss)
}

// optional .Protocol.BossType bossType = 15;
inline bool UpdatePlayerState::_internal_has_bosstype() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool UpdatePlayerState::has_bosstype() const {
  return _internal_has_bosstype();
}
inline void UpdatePlayerState::clear_bosstype() {
  _impl_.bosstype_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::Protocol::BossType UpdatePlayerState::_internal_bosstype() const {
  return static_cast< ::Protocol::BossType >(_impl_.bosstype_);
}
inline ::Protocol::BossType UpdatePlayerState::bosstype() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdatePlayerState.bossType)
  return _internal_bosstype();
}
inline void UpdatePlayerState::_internal_set_bosstype(::Protocol::BossType value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.bosstype_ = value;
}
inline void UpdatePlayerState::set_bosstype(::Protocol::BossType value) {
  _internal_set_bosstype(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdatePlayerState.bossType)
}

// -------------------------------------------------------------------

// UpdateGeneratorState

// uint32 generatorId = 1;
inline void UpdateGeneratorState::clear_generatorid() {
  _impl_.generatorid_ = 0u;
}
inline uint32_t UpdateGeneratorState::_internal_generatorid() const {
  return _impl_.generatorid_;
}
inline uint32_t UpdateGeneratorState::generatorid() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdateGeneratorState.generatorId)
  return _internal_generatorid();
}
inline void UpdateGeneratorState::_internal_set_generatorid(uint32_t value) {
  
  _impl_.generatorid_ = value;
}
inline void UpdateGeneratorState::set_generatorid(uint32_t value) {
  _internal_set_generatorid(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdateGeneratorState.generatorId)
}

// optional bool isActivated = 2;
inline bool UpdateGeneratorState::_internal_has_isactivated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateGeneratorState::has_isactivated() const {
  return _internal_has_isactivated();
}
inline void UpdateGeneratorState::clear_isactivated() {
  _impl_.isactivated_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool UpdateGeneratorState::_internal_isactivated() const {
  return _impl_.isactivated_;
}
inline bool UpdateGeneratorState::isactivated() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdateGeneratorState.isActivated)
  return _internal_isactivated();
}
inline void UpdateGeneratorState::_internal_set_isactivated(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.isactivated_ = value;
}
inline void UpdateGeneratorState::set_isactivated(bool value) {
  _internal_set_isactivated(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdateGeneratorState.isActivated)
}

// optional bool isSparkling = 3;
inline bool UpdateGeneratorState::_internal_has_issparkling() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateGeneratorState::has_issparkling() const {
  return _internal_has_issparkling();
}
inline void UpdateGeneratorState::clear_issparkling() {
  _impl_.issparkling_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool UpdateGeneratorState::_internal_issparkling() const {
  return _impl_.issparkling_;
}
inline bool UpdateGeneratorState::issparkling() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdateGeneratorState.isSparkling)
  return _internal_issparkling();
}
inline void UpdateGeneratorState::_internal_set_issparkling(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.issparkling_ = value;
}
inline void UpdateGeneratorState::set_issparkling(bool value) {
  _internal_set_issparkling(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdateGeneratorState.isSparkling)
}

// optional uint32 generatorsGage = 4;
inline bool UpdateGeneratorState::_internal_has_generatorsgage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateGeneratorState::has_generatorsgage() const {
  return _internal_has_generatorsgage();
}
inline void UpdateGeneratorState::clear_generatorsgage() {
  _impl_.generatorsgage_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t UpdateGeneratorState::_internal_generatorsgage() const {
  return _impl_.generatorsgage_;
}
inline uint32_t UpdateGeneratorState::generatorsgage() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdateGeneratorState.generatorsGage)
  return _internal_generatorsgage();
}
inline void UpdateGeneratorState::_internal_set_generatorsgage(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.generatorsgage_ = value;
}
inline void UpdateGeneratorState::set_generatorsgage(uint32_t value) {
  _internal_set_generatorsgage(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdateGeneratorState.generatorsGage)
}

// -------------------------------------------------------------------

// UpdateMiniGameState

// uint32 miniGameId = 1;
inline void UpdateMiniGameState::clear_minigameid() {
  _impl_.minigameid_ = 0u;
}
inline uint32_t UpdateMiniGameState::_internal_minigameid() const {
  return _impl_.minigameid_;
}
inline uint32_t UpdateMiniGameState::minigameid() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdateMiniGameState.miniGameId)
  return _internal_minigameid();
}
inline void UpdateMiniGameState::_internal_set_minigameid(uint32_t value) {
  
  _impl_.minigameid_ = value;
}
inline void UpdateMiniGameState::set_minigameid(uint32_t value) {
  _internal_set_minigameid(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdateMiniGameState.miniGameId)
}

// optional bool isCleared = 2;
inline bool UpdateMiniGameState::_internal_has_iscleared() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateMiniGameState::has_iscleared() const {
  return _internal_has_iscleared();
}
inline void UpdateMiniGameState::clear_iscleared() {
  _impl_.iscleared_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool UpdateMiniGameState::_internal_iscleared() const {
  return _impl_.iscleared_;
}
inline bool UpdateMiniGameState::iscleared() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdateMiniGameState.isCleared)
  return _internal_iscleared();
}
inline void UpdateMiniGameState::_internal_set_iscleared(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.iscleared_ = value;
}
inline void UpdateMiniGameState::set_iscleared(bool value) {
  _internal_set_iscleared(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdateMiniGameState.isCleared)
}

// optional bool isSparkling = 3;
inline bool UpdateMiniGameState::_internal_has_issparkling() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateMiniGameState::has_issparkling() const {
  return _internal_has_issparkling();
}
inline void UpdateMiniGameState::clear_issparkling() {
  _impl_.issparkling_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool UpdateMiniGameState::_internal_issparkling() const {
  return _impl_.issparkling_;
}
inline bool UpdateMiniGameState::issparkling() const {
  // @@protoc_insertion_point(field_get:Protocol.UpdateMiniGameState.isSparkling)
  return _internal_issparkling();
}
inline void UpdateMiniGameState::_internal_set_issparkling(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.issparkling_ = value;
}
inline void UpdateMiniGameState::set_issparkling(bool value) {
  _internal_set_issparkling(value);
  // @@protoc_insertion_point(field_set:Protocol.UpdateMiniGameState.isSparkling)
}

// -------------------------------------------------------------------

// WorldStateDelta

// repeated .Protocol.UpdatePlayerState playerUpdates = 1;
inline int WorldStateDelta::_internal_playerupdates_size() const {
  return _impl_.playerupdates_.size();
}
inline int WorldStateDelta::playerupdates_size() const {
  return _internal_playerupdates_size();
}
inline void WorldStateDelta::clear_playerupdates() {
  _impl_.playerupdates_.Clear();
}
inline ::Protocol::UpdatePlayerState* WorldStateDelta::mutable_playerupdates(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.WorldStateDelta.playerUpdates)
  return _impl_.playerupdates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdatePlayerState >*
WorldStateDelta::mutable_playerupdates() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.WorldStateDelta.playerUpdates)
  return &_impl_.playerupdates_;
}
inline const ::Protocol::UpdatePlayerState& WorldStateDelta::_internal_playerupdates(int index) const {
  return _impl_.playerupdates_.Get(index);
}
inline const ::Protocol::UpdatePlayerState& WorldStateDelta::playerupdates(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.WorldStateDelta.playerUpdates)
  return _internal_playerupdates(index);
}
inline ::Protocol::UpdatePlayerState* WorldStateDelta::_internal_add_playerupdates() {
  return _impl_.playerupdates_.Add();
}
inline ::Protocol::UpdatePlayerState* WorldStateDelta::add_playerupdates() {
  ::Protocol::UpdatePlayerState* _add = _internal_add_playerupdates();
  // @@protoc_insertion_point(field_add:Protocol.WorldStateDelta.playerUpdates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdatePlayerState >&
WorldStateDelta::playerupdates() const {
  // @@protoc_insertion_point(field_list:Protocol.WorldStateDelta.playerUpdates)
  return _impl_.playerupdates_;
}

// repeated .Protocol.UpdateGeneratorState generatorUpdates = 2;
inline int WorldStateDelta::_internal_generatorupdates_size() const {
  return _impl_.generatorupdates_.size();
}
inline int WorldStateDelta::generatorupdates_size() const {
  return _internal_generatorupdates_size();
}
inline void WorldStateDelta::clear_generatorupdates() {
  _impl_.generatorupdates_.Clear();
}
inline ::Protocol::UpdateGeneratorState* WorldStateDelta::mutable_generatorupdates(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.WorldStateDelta.generatorUpdates)
  return _impl_.generatorupdates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdateGeneratorState >*
WorldStateDelta::mutable_generatorupdates() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.WorldStateDelta.generatorUpdates)
  return &_impl_.generatorupdates_;
}
inline const ::Protocol::UpdateGeneratorState& WorldStateDelta::_internal_generatorupdates(int index) const {
  return _impl_.generatorupdates_.Get(index);
}
inline const ::Protocol::UpdateGeneratorState& WorldStateDelta::generatorupdates(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.WorldStateDelta.generatorUpdates)
  return _internal_generatorupdates(index);
}
inline ::Protocol::UpdateGeneratorState* WorldStateDelta::_internal_add_generatorupdates() {
  return _impl_.generatorupdates_.Add();
}
inline ::Protocol::UpdateGeneratorState* WorldStateDelta::add_generatorupdates() {
  ::Protocol::UpdateGeneratorState* _add = _internal_add_generatorupdates();
  // @@protoc_insertion_point(field_add:Protocol.WorldStateDelta.generatorUpdates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdateGeneratorState >&
WorldStateDelta::generatorupdates() const {
  // @@protoc_insertion_point(field_list:Protocol.WorldStateDelta.generatorUpdates)
  return _impl_.generatorupdates_;
}

// repeated .Protocol.UpdateMiniGameState miniUpdates = 3;
inline int WorldStateDelta::_internal_miniupdates_size() const {
  return _impl_.miniupdates_.size();
}
inline int WorldStateDelta::miniupdates_size() const {
  return _internal_miniupdates_size();
}
inline void WorldStateDelta::clear_miniupdates() {
  _impl_.miniupdates_.Clear();
}
inline ::Protocol::UpdateMiniGameState* WorldStateDelta::mutable_miniupdates(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.WorldStateDelta.miniUpdates)
  return _impl_.miniupdates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdateMiniGameState >*
WorldStateDelta::mutable_miniupdates() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.WorldStateDelta.miniUpdates)
  return &_impl_.miniupdates_;
}
inline const ::Protocol::UpdateMiniGameState& WorldStateDelta::_internal_miniupdates(int index) const {
  return _impl_.miniupdates_.Get(index);
}
inline const ::Protocol::UpdateMiniGameState& WorldStateDelta::miniupdates(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.WorldStateDelta.miniUpdates)
  return _internal_miniupdates(index);
}
inline ::Protocol::UpdateMiniGameState* WorldStateDelta::_internal_add_miniupdates() {
  return _impl_.miniupdates_.Add();
}
inline ::Protocol::UpdateMiniGameState* WorldStateDelta::add_miniupdates() {
  ::Protocol::UpdateMiniGameState* _add = _internal_add_miniupdates();
  // @@protoc_insertion_point(field_add:Protocol.WorldStateDelta.miniUpdates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::UpdateMiniGameState >&
WorldStateDelta::miniupdates() const {
  // @@protoc_insertion_point(field_list:Protocol.WorldStateDelta.miniUpdates)
  return _impl_.miniupdates_;
}

// -------------------------------------------------------------------

// PlayerMoveRequest

// uint32 actorId = 1;
inline void PlayerMoveRequest::clear_actorid() {
  _impl_.actorid_ = 0u;
}
inline uint32_t PlayerMoveRequest::_internal_actorid() const {
  return _impl_.actorid_;
}
inline uint32_t PlayerMoveRequest::actorid() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerMoveRequest.actorId)
  return _internal_actorid();
}
inline void PlayerMoveRequest::_internal_set_actorid(uint32_t value) {
  
  _impl_.actorid_ = value;
}
inline void PlayerMoveRequest::set_actorid(uint32_t value) {
  _internal_set_actorid(value);
  // @@protoc_insertion_point(field_set:Protocol.PlayerMoveRequest.actorId)
}

// .Protocol.Vector3 newPosition = 2;
inline bool PlayerMoveRequest::_internal_has_newposition() const {
  return this != internal_default_instance() && _impl_.newposition_ != nullptr;
}
inline bool PlayerMoveRequest::has_newposition() const {
  return _internal_has_newposition();
}
inline const ::Protocol::Vector3& PlayerMoveRequest::_internal_newposition() const {
  const ::Protocol::Vector3* p = _impl_.newposition_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector3&>(
      ::Protocol::_Vector3_default_instance_);
}
inline const ::Protocol::Vector3& PlayerMoveRequest::newposition() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerMoveRequest.newPosition)
  return _internal_newposition();
}
inline void PlayerMoveRequest::unsafe_arena_set_allocated_newposition(
    ::Protocol::Vector3* newposition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.newposition_);
  }
  _impl_.newposition_ = newposition;
  if (newposition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerMoveRequest.newPosition)
}
inline ::Protocol::Vector3* PlayerMoveRequest::release_newposition() {
  
  ::Protocol::Vector3* temp = _impl_.newposition_;
  _impl_.newposition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Vector3* PlayerMoveRequest::unsafe_arena_release_newposition() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerMoveRequest.newPosition)
  
  ::Protocol::Vector3* temp = _impl_.newposition_;
  _impl_.newposition_ = nullptr;
  return temp;
}
inline ::Protocol::Vector3* PlayerMoveRequest::_internal_mutable_newposition() {
  
  if (_impl_.newposition_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector3>(GetArenaForAllocation());
    _impl_.newposition_ = p;
  }
  return _impl_.newposition_;
}
inline ::Protocol::Vector3* PlayerMoveRequest::mutable_newposition() {
  ::Protocol::Vector3* _msg = _internal_mutable_newposition();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerMoveRequest.newPosition)
  return _msg;
}
inline void PlayerMoveRequest::set_allocated_newposition(::Protocol::Vector3* newposition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.newposition_);
  }
  if (newposition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(newposition));
    if (message_arena != submessage_arena) {
      newposition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, newposition, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.newposition_ = newposition;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerMoveRequest.newPosition)
}

// .Protocol.Vector3 rotation = 3;
inline bool PlayerMoveRequest::_internal_has_rotation() const {
  return this != internal_default_instance() && _impl_.rotation_ != nullptr;
}
inline bool PlayerMoveRequest::has_rotation() const {
  return _internal_has_rotation();
}
inline const ::Protocol::Vector3& PlayerMoveRequest::_internal_rotation() const {
  const ::Protocol::Vector3* p = _impl_.rotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::Vector3&>(
      ::Protocol::_Vector3_default_instance_);
}
inline const ::Protocol::Vector3& PlayerMoveRequest::rotation() const {
  // @@protoc_insertion_point(field_get:Protocol.PlayerMoveRequest.rotation)
  return _internal_rotation();
}
inline void PlayerMoveRequest::unsafe_arena_set_allocated_rotation(
    ::Protocol::Vector3* rotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  _impl_.rotation_ = rotation;
  if (rotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PlayerMoveRequest.rotation)
}
inline ::Protocol::Vector3* PlayerMoveRequest::release_rotation() {
  
  ::Protocol::Vector3* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::Vector3* PlayerMoveRequest::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:Protocol.PlayerMoveRequest.rotation)
  
  ::Protocol::Vector3* temp = _impl_.rotation_;
  _impl_.rotation_ = nullptr;
  return temp;
}
inline ::Protocol::Vector3* PlayerMoveRequest::_internal_mutable_rotation() {
  
  if (_impl_.rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::Vector3>(GetArenaForAllocation());
    _impl_.rotation_ = p;
  }
  return _impl_.rotation_;
}
inline ::Protocol::Vector3* PlayerMoveRequest::mutable_rotation() {
  ::Protocol::Vector3* _msg = _internal_mutable_rotation();
  // @@protoc_insertion_point(field_mutable:Protocol.PlayerMoveRequest.rotation)
  return _msg;
}
inline void PlayerMoveRequest::set_allocated_rotation(::Protocol::Vector3* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rotation_);
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation));
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PlayerMoveRequest.rotation)
}

// -------------------------------------------------------------------

// ChatRequest

// uint32 sender_id = 1;
inline void ChatRequest::clear_sender_id() {
  _impl_.sender_id_ = 0u;
}
inline uint32_t ChatRequest::_internal_sender_id() const {
  return _impl_.sender_id_;
}
inline uint32_t ChatRequest::sender_id() const {
  // @@protoc_insertion_point(field_get:Protocol.ChatRequest.sender_id)
  return _internal_sender_id();
}
inline void ChatRequest::_internal_set_sender_id(uint32_t value) {
  
  _impl_.sender_id_ = value;
}
inline void ChatRequest::set_sender_id(uint32_t value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:Protocol.ChatRequest.sender_id)
}

// string message = 2;
inline void ChatRequest::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ChatRequest::message() const {
  // @@protoc_insertion_point(field_get:Protocol.ChatRequest.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatRequest::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.ChatRequest.message)
}
inline std::string* ChatRequest::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Protocol.ChatRequest.message)
  return _s;
}
inline const std::string& ChatRequest::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ChatRequest::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatRequest::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatRequest::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.ChatRequest.message)
  return _impl_.message_.Release();
}
inline void ChatRequest::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.ChatRequest.message)
}

// -------------------------------------------------------------------

// ChatResponse

// uint32 sender_id = 1;
inline void ChatResponse::clear_sender_id() {
  _impl_.sender_id_ = 0u;
}
inline uint32_t ChatResponse::_internal_sender_id() const {
  return _impl_.sender_id_;
}
inline uint32_t ChatResponse::sender_id() const {
  // @@protoc_insertion_point(field_get:Protocol.ChatResponse.sender_id)
  return _internal_sender_id();
}
inline void ChatResponse::_internal_set_sender_id(uint32_t value) {
  
  _impl_.sender_id_ = value;
}
inline void ChatResponse::set_sender_id(uint32_t value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:Protocol.ChatResponse.sender_id)
}

// string message = 2;
inline void ChatResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ChatResponse::message() const {
  // @@protoc_insertion_point(field_get:Protocol.ChatResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChatResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.ChatResponse.message)
}
inline std::string* ChatResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Protocol.ChatResponse.message)
  return _s;
}
inline const std::string& ChatResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ChatResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ChatResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ChatResponse::release_message() {
  // @@protoc_insertion_point(field_release:Protocol.ChatResponse.message)
  return _impl_.message_.Release();
}
inline void ChatResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.ChatResponse.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
